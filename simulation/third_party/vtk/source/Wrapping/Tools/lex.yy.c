#define YY_INT_ALIGNED short int

/* A lexical scanner generated by flex */

#define FLEX_SCANNER
#define YY_FLEX_MAJOR_VERSION 2
#define YY_FLEX_MINOR_VERSION 6
#define YY_FLEX_SUBMINOR_VERSION 4
#if YY_FLEX_SUBMINOR_VERSION > 0
#define FLEX_BETA
#endif

/* First, we deal with  platform-specific or compiler-specific issues. */

/* begin standard C headers. */
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* end standard C headers. */

#ifndef __cplusplus
extern int isatty(int);
#endif /* __cplusplus */

/* flex integer type definitions */

#ifndef FLEXINT_H
#define FLEXINT_H

/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */

#if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L

/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
 * if you want the limit (max/min) macros for int types.
 */
#ifndef __STDC_LIMIT_MACROS
#define __STDC_LIMIT_MACROS 1
#endif

#include <inttypes.h>
typedef int8_t flex_int8_t;
typedef uint8_t flex_uint8_t;
typedef int16_t flex_int16_t;
typedef uint16_t flex_uint16_t;
typedef int32_t flex_int32_t;
typedef uint32_t flex_uint32_t;
#else
typedef signed char flex_int8_t;
typedef short int flex_int16_t;
typedef int flex_int32_t;
typedef unsigned char flex_uint8_t;
typedef unsigned short int flex_uint16_t;
typedef unsigned int flex_uint32_t;

/* Limits of integral types. */
#ifndef INT8_MIN
#define INT8_MIN (-128)
#endif
#ifndef INT16_MIN
#define INT16_MIN (-32767 - 1)
#endif
#ifndef INT32_MIN
#define INT32_MIN (-2147483647 - 1)
#endif
#ifndef INT8_MAX
#define INT8_MAX (127)
#endif
#ifndef INT16_MAX
#define INT16_MAX (32767)
#endif
#ifndef INT32_MAX
#define INT32_MAX (2147483647)
#endif
#ifndef UINT8_MAX
#define UINT8_MAX (255U)
#endif
#ifndef UINT16_MAX
#define UINT16_MAX (65535U)
#endif
#ifndef UINT32_MAX
#define UINT32_MAX (4294967295U)
#endif

#ifndef SIZE_MAX
#define SIZE_MAX (~(size_t)0)
#endif

#endif /* ! C99 */

#endif /* ! FLEXINT_H */

/* begin standard C++ headers. */

/* TODO: this is always defined, so inline it */
#define yyconst const

#if defined(__GNUC__) && __GNUC__ >= 3
#define yynoreturn __attribute__((__noreturn__))
#else
#define yynoreturn
#endif

/* Returned upon end-of-file. */
#define YY_NULL 0

/* Promotes a possibly negative, possibly signed char to an
 *   integer in range [0..255] for use as an array index.
 */
#define YY_SC_TO_UI(c) ((YY_CHAR)(c))

/* Enter a start condition.  This macro really ought to take a parameter,
 * but we do it the disgusting crufty way forced on us by the ()-less
 * definition of BEGIN.
 */
#define BEGIN (yy_start) = 1 + 2 *
/* Translate the current start state into a value that can be later handed
 * to BEGIN to return to the state.  The YYSTATE alias is for lex
 * compatibility.
 */
#define YY_START (((yy_start)-1) / 2)
#define YYSTATE YY_START
/* Action number for EOF rule of a given start state. */
#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
/* Special action meaning "start processing a new file". */
#define YY_NEW_FILE yyrestart(yyin)
#define YY_END_OF_BUFFER_CHAR 0

/* Size of default input buffer. */
#ifndef YY_BUF_SIZE
#ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k.
 * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.
 * Ditto for the __ia64__ case accordingly.
 */
#define YY_BUF_SIZE 32768
#else
#define YY_BUF_SIZE 16384
#endif /* __ia64__ */
#endif

/* The state buf must be large enough to hold one state per character in the main buffer.
 */
#define YY_STATE_BUF_SIZE ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))

#ifndef YY_TYPEDEF_YY_BUFFER_STATE
#define YY_TYPEDEF_YY_BUFFER_STATE
typedef struct yy_buffer_state* YY_BUFFER_STATE;
#endif

#ifndef YY_TYPEDEF_YY_SIZE_T
#define YY_TYPEDEF_YY_SIZE_T
typedef size_t yy_size_t;
#endif

extern int yyleng;

extern FILE *yyin, *yyout;

#define EOB_ACT_CONTINUE_SCAN 0
#define EOB_ACT_END_OF_FILE 1
#define EOB_ACT_LAST_MATCH 2

/* Note: We specifically omit the test for yy_rule_can_match_eol because it requires
 *       access to the local variable yy_act. Since yyless() is a macro, it would break
 *       existing scanners that call yyless() from OUTSIDE yylex.
 *       One obvious solution it to make yy_act a global. I tried that, and saw
 *       a 5% performance hit in a non-yylineno scanner, because yy_act is
 *       normally declared as a register variable-- so it is not worth it.
 */
#define YY_LESS_LINENO(n)                                                                          \
  do                                                                                               \
  {                                                                                                \
    int yyl;                                                                                       \
    for (yyl = n; yyl < yyleng; ++yyl)                                                             \
      if (yytext[yyl] == '\n')                                                                     \
        --yylineno;                                                                                \
  } while (0)
#define YY_LINENO_REWIND_TO(dst)                                                                   \
  do                                                                                               \
  {                                                                                                \
    const char* p;                                                                                 \
    for (p = yy_cp - 1; p >= (dst); --p)                                                           \
      if (*p == '\n')                                                                              \
        --yylineno;                                                                                \
  } while (0)

/* Return all but the first "n" matched characters back to the input stream. */
#define yyless(n)                                                                                  \
  do                                                                                               \
  {                                                                                                \
    /* Undo effects of setting up yytext. */                                                       \
    int yyless_macro_arg = (n);                                                                    \
    YY_LESS_LINENO(yyless_macro_arg);                                                              \
    *yy_cp = (yy_hold_char);                                                                       \
    YY_RESTORE_YY_MORE_OFFSET(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ;        \
    YY_DO_BEFORE_ACTION; /* set up yytext again */                                                 \
  } while (0)
#define unput(c) yyunput(c, (yytext_ptr))

#ifndef YY_STRUCT_YY_BUFFER_STATE
#define YY_STRUCT_YY_BUFFER_STATE
struct yy_buffer_state
{
  FILE* yy_input_file;

  char* yy_ch_buf;  /* input buffer */
  char* yy_buf_pos; /* current position in input buffer */

  /* Size of input buffer in bytes, not including room for EOB
   * characters.
   */
  int yy_buf_size;

  /* Number of characters read into yy_ch_buf, not including EOB
   * characters.
   */
  int yy_n_chars;

  /* Whether we "own" the buffer - i.e., we know we created it,
   * and can realloc() it to grow it, and should free() it to
   * delete it.
   */
  int yy_is_our_buffer;

  /* Whether this is an "interactive" input source; if so, and
   * if we're using stdio for input, then we want to use getc()
   * instead of fread(), to make sure we stop fetching input after
   * each newline.
   */
  int yy_is_interactive;

  /* Whether we're considered to be at the beginning of a line.
   * If so, '^' rules will be active on the next match, otherwise
   * not.
   */
  int yy_at_bol;

  int yy_bs_lineno; /**< The line count. */
  int yy_bs_column; /**< The column count. */

  /* Whether to try to fill the input buffer when we reach the
   * end of it.
   */
  int yy_fill_buffer;

  int yy_buffer_status;

#define YY_BUFFER_NEW 0
#define YY_BUFFER_NORMAL 1
  /* When an EOF's been seen but there's still some text to process
   * then we mark the buffer as YY_EOF_PENDING, to indicate that we
   * shouldn't try reading from the input source any more.  We might
   * still have a bunch of tokens to match, though, because of
   * possible backing-up.
   *
   * When we actually see the EOF, we change the status to "new"
   * (via yyrestart()), so that the user can continue scanning by
   * just pointing yyin at a new input file.
   */
#define YY_BUFFER_EOF_PENDING 2
};
#endif /* !YY_STRUCT_YY_BUFFER_STATE */

/* Stack of input buffers. */
static size_t yy_buffer_stack_top = 0;          /**< index of top of stack. */
static size_t yy_buffer_stack_max = 0;          /**< capacity of stack. */
static YY_BUFFER_STATE* yy_buffer_stack = NULL; /**< Stack as an array. */

/* We provide macros for accessing buffer states in case in the
 * future we want to put the buffer states in a more general
 * "scanner state".
 *
 * Returns the top of the stack, or NULL.
 */
#define YY_CURRENT_BUFFER ((yy_buffer_stack) ? (yy_buffer_stack)[(yy_buffer_stack_top)] : NULL)
/* Same as previous macro, but useful when we know that the buffer stack is not
 * NULL or when we need an lvalue. For internal use only.
 */
#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]

/* yy_hold_char holds the character lost when yytext is formed. */
static char yy_hold_char;
static int yy_n_chars; /* number of characters read into yy_ch_buf */
int yyleng;

/* Points to current character in buffer. */
static char* yy_c_buf_p = NULL;
static int yy_init = 0;  /* whether we need to initialize */
static int yy_start = 0; /* start state number */

/* Flag which is used to allow yywrap()'s to do buffer switches
 * instead of setting up a fresh yyin.  A bit of a hack ...
 */
static int yy_did_buffer_switch_on_eof;

void yyrestart(FILE* input_file);
void yy_switch_to_buffer(YY_BUFFER_STATE new_buffer);
YY_BUFFER_STATE yy_create_buffer(FILE* file, int size);
void yy_delete_buffer(YY_BUFFER_STATE b);
void yy_flush_buffer(YY_BUFFER_STATE b);
void yypush_buffer_state(YY_BUFFER_STATE new_buffer);
void yypop_buffer_state(void);

static void yyensure_buffer_stack(void);
static void yy_load_buffer_state(void);
static void yy_init_buffer(YY_BUFFER_STATE b, FILE* file);
#define YY_FLUSH_BUFFER yy_flush_buffer(YY_CURRENT_BUFFER)

YY_BUFFER_STATE yy_scan_buffer(char* base, yy_size_t size);
YY_BUFFER_STATE yy_scan_string(const char* yy_str);
YY_BUFFER_STATE yy_scan_bytes(const char* bytes, int len);

void* yyalloc(yy_size_t);
void* yyrealloc(void*, yy_size_t);
void yyfree(void*);

#define yy_new_buffer yy_create_buffer
#define yy_set_interactive(is_interactive)                                                         \
  {                                                                                                \
    if (!YY_CURRENT_BUFFER)                                                                        \
    {                                                                                              \
      yyensure_buffer_stack();                                                                     \
      YY_CURRENT_BUFFER_LVALUE = yy_create_buffer(yyin, YY_BUF_SIZE);                              \
    }                                                                                              \
    YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive;                                  \
  }
#define yy_set_bol(at_bol)                                                                         \
  {                                                                                                \
    if (!YY_CURRENT_BUFFER)                                                                        \
    {                                                                                              \
      yyensure_buffer_stack();                                                                     \
      YY_CURRENT_BUFFER_LVALUE = yy_create_buffer(yyin, YY_BUF_SIZE);                              \
    }                                                                                              \
    YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol;                                                  \
  }
#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)

/* Begin user sect3 */
typedef flex_uint8_t YY_CHAR;

FILE *yyin = NULL, *yyout = NULL;

typedef int yy_state_type;

extern int yylineno;
int yylineno = 1;

extern char* yytext;
#ifdef yytext_ptr
#undef yytext_ptr
#endif
#define yytext_ptr yytext

static yy_state_type yy_get_previous_state(void);
static yy_state_type yy_try_NUL_trans(yy_state_type current_state);
static int yy_get_next_buffer(void);
static void yynoreturn yy_fatal_error(const char* msg);

/* Done after the current pattern has been matched and before the
 * corresponding action - sets up yytext.
 */
#define YY_DO_BEFORE_ACTION                                                                        \
  (yytext_ptr) = yy_bp;                                                                            \
  yyleng = (int)(yy_cp - yy_bp);                                                                   \
  (yy_hold_char) = *yy_cp;                                                                         \
  *yy_cp = '\0';                                                                                   \
  (yy_c_buf_p) = yy_cp;
#define YY_NUM_RULES 164
#define YY_END_OF_BUFFER 165
/* This struct is not used in this scanner,
   but its presence is necessary. */
static const flex_int16_t yy_accept[963] = { 0, 0, 0, 165, 163, 127, 128, 128, 162, 163, 162, 162,
  163, 162, 162, 162, 162, 162, 162, 162, 125, 124, 162, 162, 162, 162, 116, 116, 116, 116, 116,
  116, 116, 116, 160, 163, 161, 162, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116,
  116, 116, 116, 116, 116, 116, 116, 116, 162, 127, 13, 13, 15, 162, 163, 127, 155, 0, 16, 0, 134,
  148, 131, 152, 149, 0, 0, 0, 89, 90, 0, 0, 0, 0, 0, 146, 142, 144, 143, 145, 141, 139, 0, 117, 3,
  14, 147, 0, 118, 123, 0,

  0, 0, 0, 0, 124, 124, 124, 159, 133, 130, 132, 138, 156, 154, 157, 135, 116, 116, 116, 0, 0, 116,
  116, 116, 0, 116, 0, 129, 126, 0, 151, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116,
  116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 80,
  116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116,
  116, 150, 153, 127, 13, 15, 0, 0, 15, 15, 3, 12, 0, 0, 0, 17, 0, 0,

  0, 0, 0, 0, 140, 158, 0, 117, 117, 117, 0, 14, 14, 119, 118, 118, 123, 123, 0, 122, 0, 120, 121,
  124, 120, 136, 137, 116, 116, 116, 0, 0, 18, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116,
  116, 116, 116, 116, 116, 116, 78, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116,
  116, 116, 116, 116, 116, 116, 25, 116, 116, 116, 116, 64, 116, 82, 116, 116, 116, 116, 116, 116,
  116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 68, 116, 116, 116, 116,

  116, 116, 116, 116, 116, 84, 0, 12, 15, 2, 12, 12, 6, 12, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  117, 0, 117, 1, 5, 0, 119, 119, 119, 118, 0, 118, 123, 120, 0, 122, 122, 0, 120, 120, 0, 121, 121,
  121, 120, 120, 116, 116, 116, 0, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116,
  116, 116, 116, 116, 116, 19, 116, 116, 29, 116, 24, 116, 116, 116, 116, 116, 116, 116, 116, 46,
  116, 116, 116, 116, 116, 116, 23, 116, 116, 116,

  116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 0, 116, 116, 116, 116,
  116, 116, 116, 116, 116, 116, 28, 116, 116, 116, 116, 2, 12, 12, 6, 12, 12, 12, 6, 5, 7, 8, 0, 0,
  16, 17, 0, 0, 0, 0, 0, 0, 0, 0, 117, 0, 117, 117, 5, 119, 0, 119, 118, 0, 118, 118, 120, 120, 122,
  120, 121, 121, 121, 121, 120, 116, 116, 116, 100, 116, 116, 116, 116, 116, 116, 116, 116, 116,
  116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 87, 69,

  116, 116, 41, 88, 49, 116, 116, 116, 116, 116, 116, 116, 21, 116, 116, 116, 116, 116, 116, 116,
  116, 116, 81, 116, 116, 116, 116, 116, 116, 22, 116, 116, 116, 116, 116, 0, 116, 116, 116, 116,
  67, 116, 116, 47, 116, 63, 116, 116, 116, 116, 116, 12, 12, 6, 7, 8, 12, 12, 12, 5, 7, 8, 0, 0,
  17, 0, 0, 0, 0, 0, 0, 0, 0, 117, 119, 0, 119, 119, 118, 120, 116, 116, 116, 100, 95, 116, 116,
  116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116, 116,

  116, 79, 86, 116, 116, 116, 116, 116, 116, 65, 20, 116, 116, 58, 53, 54, 116, 116, 116, 116, 83,
  116, 116, 116, 116, 116, 43, 116, 116, 116, 27, 116, 116, 56, 0, 0, 0, 0, 116, 42, 116, 116, 116,
  116, 116, 116, 116, 116, 116, 85, 12, 12, 12, 7, 8, 12, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 119,
  116, 116, 116, 94, 116, 106, 116, 116, 108, 116, 116, 112, 116, 116, 116, 116, 116, 116, 116, 102,
  116, 116, 116, 116, 116, 72, 116, 116, 116, 51, 116,

  116, 115, 116, 116, 44, 116, 0, 116, 116, 116, 33, 33, 116, 116, 0, 0, 0, 0, 0, 0, 98, 98, 116,
  116, 61, 116, 116, 48, 116, 116, 32, 12, 12, 12, 12, 12, 12, 0, 0, 0, 0, 0, 92, 93, 0, 0, 0, 0, 0,
  95, 95, 36, 103, 104, 116, 116, 116, 116, 116, 116, 109, 116, 116, 116, 30, 31, 116, 116, 71, 116,
  66, 97, 97, 116, 70, 116, 52, 96, 96, 0, 116, 0, 77, 116, 0, 40, 34, 34, 116, 116, 0, 0, 0, 0, 0,
  0, 59, 116, 60, 26,

  50, 116, 12, 12, 12, 12, 12, 12, 0, 0, 0, 0, 0, 91, 0, 0, 0, 0, 107, 116, 116, 116, 116, 116, 116,
  116, 55, 116, 62, 116, 0, 45, 0, 116, 116, 116, 0, 0, 0, 0, 0, 0, 116, 116, 12, 12, 12, 10, 12,
  12, 0, 0, 0, 0, 116, 116, 111, 114, 75, 116, 35, 35, 0, 0, 0, 116, 116, 116, 0, 0, 0, 0, 0, 0,
  116, 116, 10, 12, 12, 10, 12, 12, 0, 4, 116, 116, 116, 116, 0, 0, 0, 116, 116, 73, 0, 0, 0, 0, 0,
  0,

  116, 116, 10, 12, 12, 12, 12, 0, 116, 116, 113, 74, 0, 0, 0, 116, 116, 0, 0, 0, 0, 57, 99, 12, 12,
  11, 12, 0, 105, 110, 0, 0, 0, 37, 116, 101, 0, 11, 12, 11, 12, 0, 0, 38, 0, 116, 0, 11, 12, 12, 0,
  0, 116, 12, 9, 0, 39, 76, 9, 9, 9, 0 };

static const YY_CHAR yy_ec[256] = { 0, 1, 1, 1, 1, 1, 1, 1, 1, 2, 3, 4, 4, 5, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 6, 7, 8, 9, 1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21,
  22, 23, 24, 25, 25, 26, 25, 27, 28, 29, 17, 30, 31, 32, 1, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42,
  43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 41, 55, 56, 57, 41, 58, 59, 60, 61, 62, 1, 63, 64,
  65, 66,

  67, 68, 69, 70, 71, 41, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89,
  90, 17, 1, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91,
  91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91,
  91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91,
  91, 91, 91,

  91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91,
  91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91,
  91, 91, 91, 91, 91, 91, 91 };

static const YY_CHAR yy_meta[92] = { 0, 1, 2, 3, 4, 5, 2, 1, 1, 1, 1, 6, 7, 1, 4, 6, 1, 1, 1, 8, 1,
  9, 9, 10, 10, 10, 10, 10, 10, 11, 1, 1, 1, 1, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13,
  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 1, 1, 1, 1, 13, 12, 12, 12, 12, 12, 12, 13, 13, 13,
  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 1, 1, 1, 14

};

static const flex_int16_t yy_base[1069] = { 0, 0, 90, 2751, 2752, 92, 2752, 2752, 2719, 89, 71, 90,
  2690, 102, 2752, 2717, 93, 88, 107, 96, 153, 128, 83, 115, 2716, 110, 2697, 0, 2711, 131, 56,
  2736, 150, 2701, 165, 156, 2752, 2711, 149, 111, 114, 124, 132, 88, 131, 132, 2665, 2658, 152,
  126, 134, 2672, 151, 157, 217, 159, 2673, 2661, 161, 243, 2752, 2752, 2677, 222, 2664, 245, 2752,
  206, 2672, 2728, 2752, 2752, 2752, 2752, 2752, 214, 157, 255, 2752, 2752, 210, 2703, 233, 212,
  226, 2752, 2752, 2752, 2752, 2752, 2716, 2752, 2711, 257, 249, 267, 2752, 277, 304, 322, 340,

  250, 358, 0, 369, 387, 0, 405, 2752, 2752, 2752, 2752, 2698, 2752, 2752, 2752, 2697, 0, 2685,
  2681, 278, 2666, 2716, 2675, 2693, 2708, 2673, 317, 2752, 2752, 2716, 2752, 233, 2651, 2641, 2637,
  2645, 371, 2643, 2647, 2631, 2630, 2634, 2628, 2645, 2644, 219, 243, 2624, 2630, 2622, 232, 2627,
  2631, 234, 2620, 2625, 2618, 2624, 2613, 254, 2623, 2628, 2632, 2612, 262, 2628, 206, 2615, 249,
  2619, 290, 2615, 2609, 2601, 2609, 365, 364, 2614, 2605, 284, 2611, 2612, 2602, 2752, 2752, 440,
  2752, 2621, 383, 2608, 2619, 397, 440, 451, 265, 0, 416, 2615, 2647, 2646,

  359, 267, 325, 409, 2752, 2752, 440, 470, 0, 488, 2644, 0, 2643, 505, 0, 523, 0, 536, 497, 457,
  552, 569, 586, 0, 605, 2752, 2752, 2634, 2626, 2635, 2640, 2655, 2752, 2633, 2595, 2589, 2589,
  2584, 2599, 2582, 2579, 285, 2592, 2595, 2578, 2589, 2574, 2584, 2584, 2590, 2575, 341, 2577,
  2584, 2569, 2567, 2569, 2565, 2571, 2580, 2575, 2577, 2577, 2565, 2565, 2570, 2573, 2568, 2563, 0,
  2554, 2563, 2568, 2563, 0, 2544, 2566, 2554, 2547, 2558, 2545, 2540, 2541, 2548, 2549, 2544, 2539,
  2542, 2549, 2528, 2533, 2584, 388, 2535, 405, 0, 2544, 2534, 2538, 2533,

  2526, 2540, 2542, 2552, 2540, 2540, 473, 549, 417, 2571, 0, 368, 2570, 395, 2522, 2517, 0, 479, 0,
  407, 577, 457, 471, 570, 472, 505, 470, 0, 634, 651, 2752, 0, 643, 668, 0, 686, 0, 660, 703, 0,
  720, 419, 623, 0, 695, 728, 0, 0, 745, 802, 0, 764, 0, 2550, 2561, 2552, 0, 2545, 2524, 2518,
  2524, 2512, 2496, 2494, 2479, 2470, 2444, 2454, 2438, 2442, 2424, 2425, 2419, 2402, 2409, 0, 2388,
  2383, 0, 2369, 543, 2345, 2346, 2332, 2329, 2323, 2318, 2323, 2317, 0, 2317, 2304, 2299, 2294,
  2280, 2274, 0, 2263, 2233, 2234,

  2218, 2194, 2194, 2173, 2178, 2176, 2166, 2156, 2144, 2138, 2132, 440, 2145, 2134, 2127, 2164,
  2112, 2119, 2106, 2113, 2087, 571, 2093, 2094, 2080, 2061, 0, 2056, 2053, 2050, 2059, 2752, 0,
  534, 0, 478, 536, 2048, 0, 0, 0, 0, 2036, 2028, 0, 0, 555, 507, 556, 571, 560, 618, 574, 668, 794,
  737, 821, 0, 0, 0, 772, 850, 867, 829, 875, 0, 892, 0, 0, 0, 909, 966, 0, 0, 0, 2028, 2033, 2015,
  0, 1997, 1950, 1940, 1923, 1915, 1916, 1924, 1903, 1911, 1908, 1895, 1884, 1893, 1875, 1885, 1867,
  1879, 1858, 1869, 0, 0,

  1907, 1905, 0, 0, 638, 1839, 1847, 1847, 1844, 1835, 1835, 1819, 0, 1825, 1811, 1809, 1796, 1781,
  1790, 1778, 1774, 1773, 0, 1783, 1751, 1753, 1747, 1728, 1737, 0, 1728, 1730, 1712, 1726, 1722,
  878, 1716, 1699, 1711, 1702, 0, 1698, 1697, 0, 1668, 0, 1667, 1658, 1662, 1661, 1641, 686, 1646,
  0, 0, 0, 1671, 1653, 1605, 0, 0, 0, 1615, 1584, 0, 589, 773, 880, 672, 876, 802, 877, 619, 938,
  958, 985, 1014, 0, 1031, 0, 1606, 1615, 1607, 0, 1593, 1578, 1575, 1568, 1554, 1563, 1535, 1529,
  1526, 1535, 1517, 1531, 1521, 1515, 1530, 1527,

  1511, 0, 0, 1528, 1527, 1523, 1502, 1509, 1504, 0, 0, 1519, 1512, 0, 0, 0, 1508, 1514, 1517, 1502,
  0, 1499, 1501, 1502, 1504, 1489, 772, 1502, 1489, 1487, 0, 1059, 1485, 1503, 1484, 1481, 1482,
  858, 1150, 0, 1480, 1498, 1491, 1484, 1490, 1483, 1482, 1502, 1472, 0, 1518, 1513, 1470, 0, 0,
  1503, 1512, 1445, 1435, 1440, 590, 985, 1092, 834, 541, 986, 772, 1064, 1087, 1450, 1462, 1452, 0,
  1424, 0, 1438, 1423, 0, 1439, 1436, 0, 1426, 1421, 1434, 1433, 1424, 1421, 1430, 0, 1411, 1410,
  1427, 1412, 1421, 0, 1425, 1405, 1241, 0, 1420,

  1399, 1417, 1399, 1332, 879, 1410, 1022, 1397, 1398, 922, 2752, 0, 1423, 671, 1393, 1400, 1391,
  1384, 1399, 1390, 2752, 0, 1401, 1394, 0, 1399, 1399, 0, 1397, 1382, 0, 1416, 1425, 1395, 1421,
  1405, 1378, 1352, 1355, 775, 572, 1120, 2752, 1388, 1183, 835, 894, 882, 987, 1367, 1366, 0, 0, 0,
  1339, 1340, 1330, 1338, 1343, 1336, 0, 1343, 1334, 1333, 0, 0, 1325, 1325, 0, 1338, 0, 2752, 0,
  1335, 0, 1320, 0, 2752, 0, 1125, 1334, 1325, 0, 1318, 993, 2752, 2752, 0, 1316, 1332, 1310, 1315,
  1308, 1319, 1298, 1313, 0, 1307, 0, 0,

  0, 1303, 1343, 1327, 1300, 1372, 1335, 1303, 1294, 1301, 1188, 1274, 1131, 2752, 883, 1067, 1071,
  1072, 0, 1252, 1246, 1261, 1252, 1243, 1249, 1239, 0, 1256, 0, 1514, 1245, 1042, 1241, 1249, 1235,
  1233, 1245, 1234, 1243, 1247, 1240, 1231, 1240, 1233, 1290, 1250, 1215, 0, 1235, 1201, 1194, 1169,
  1114, 1155, 1170, 1167, 0, 1171, 0, 1152, 2752, 0, 1155, 1213, 1149, 1148, 1160, 1145, 1162, 1143,
  1159, 1140, 1158, 1145, 1150, 1132, 0, 1158, 1127, 0, 1155, 1120, 1132, 2752, 1129, 1080, 1077,
  1057, 1051, 41, 153, 228, 291, 0, 379, 508, 560, 0, 622, 0,

  730, 736, 0, 787, 777, 853, 789, 780, 807, 824, 0, 0, 830, 850, 1194, 875, 871, 0, 905, 0, 0, 0,
  0, 962, 898, 0, 895, 926, 0, 0, 1279, 936, 1285, 2752, 955, 0, 938, 0, 944, 0, 948, 970, 1292,
  2752, 969, 1023, 0, 0, 1029, 1076, 1031, 1365, 1035, 1095, 0, 1370, 2752, 0, 0, 0, 0, 2752, 1605,
  1619, 1632, 1640, 1646, 1660, 1666, 1674, 1688, 1694, 1702, 1708, 1712, 1726, 1740, 1743, 1749,
  1757, 1763, 1769, 1777, 1785, 1793, 1801, 1815, 1829, 1835, 1838, 1847, 1853, 1861, 1875, 1883,
  1889, 1895, 1903, 1909, 1917,

  1925, 1931, 1939, 1945, 1951, 1957, 1965, 1971, 1979, 1985, 1991, 1994, 2008, 2022, 2036, 2050,
  2064, 2078, 2092, 2098, 2104, 2110, 2118, 2126, 2132, 2146, 2152, 2160, 2168, 2176, 2182, 2190,
  2196, 2202, 2208, 2216, 2222, 2228, 2234, 2240, 2254, 2268, 2282, 2296, 2310, 2324, 2338, 2352,
  2358, 2364, 2372, 2380, 2388, 2394, 2402, 2408, 2422, 2436, 2450, 2464, 2478, 2492, 2506, 2520,
  2534, 2548, 2562, 2576 };

static const flex_int16_t yy_def[1069] = { 0, 962, 1, 962, 962, 962, 962, 962, 962, 963, 962, 962,
  964, 965, 962, 962, 962, 962, 962, 962, 962, 966, 962, 962, 962, 962, 967, 967, 967, 967, 967,
  967, 967, 967, 962, 962, 962, 962, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967,
  967, 967, 967, 967, 967, 967, 967, 967, 962, 962, 962, 962, 968, 962, 962, 962, 962, 963, 962,
  963, 962, 962, 962, 962, 962, 964, 964, 965, 962, 962, 969, 969, 969, 969, 969, 962, 962, 962,
  962, 962, 962, 962, 962, 970, 962, 971, 962, 962, 972, 973, 962,

  962, 962, 974, 962, 966, 975, 975, 962, 962, 962, 962, 962, 962, 962, 962, 962, 967, 967, 967,
  963, 964, 967, 967, 967, 976, 967, 962, 962, 962, 962, 962, 967, 967, 967, 967, 967, 967, 967,
  967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967,
  967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967,
  967, 967, 967, 967, 967, 967, 967, 962, 962, 962, 962, 968, 962, 962, 968, 968, 962, 977, 962,
  978, 963, 962, 969, 962,

  969, 969, 969, 969, 962, 962, 962, 970, 979, 979, 962, 971, 971, 980, 981, 981, 982, 982, 962,
  983, 962, 984, 985, 975, 986, 962, 962, 967, 967, 967, 962, 976, 962, 967, 967, 967, 967, 967,
  967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967,
  967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967,
  967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967, 967,
  967, 967, 967, 967, 967,

  967, 967, 967, 967, 967, 967, 962, 987, 968, 962, 977, 977, 988, 977, 962, 962, 989, 963, 990,
  991, 992, 992, 992, 992, 992, 992, 992, 979, 962, 993, 962, 994, 962, 995, 996, 996, 997, 962,
  998, 999, 1000, 962, 1001, 1002, 962, 1003, 1004, 1005, 1006, 1007, 1008, 1009, 1010, 1011, 1011,
  1011, 1012, 1011, 1011, 1011, 1011, 1011, 1011, 1011, 1011, 1011, 1011, 1011, 1011, 1011, 1011,
  1011, 1011, 1011, 1011, 1011, 1011, 1011, 1011, 1011, 1011, 1011, 1011, 1011, 1011, 1011, 1011,
  1011, 1011, 1011, 1011, 1011, 1011, 1011, 1011, 1011, 1011, 1011, 1011, 1011,

  1011, 1011, 1011, 1011, 1011, 1011, 1011, 1011, 1011, 1011, 1011, 1011, 1011, 1011, 1011, 962,
  1011, 1011, 1011, 1011, 1011, 1011, 1011, 1011, 1011, 1011, 1011, 1011, 1011, 1011, 1011, 962,
  1013, 1013, 1014, 1013, 1015, 1015, 1016, 1017, 1018, 1019, 962, 962, 1020, 1021, 1022, 1022,
  1022, 1022, 1022, 1022, 1022, 1022, 1023, 962, 1024, 1025, 1026, 1027, 962, 1028, 1029, 962, 1030,
  1031, 1032, 1033, 1034, 1035, 1036, 1036, 1037, 1037, 1038, 1039, 1039, 1039, 1040, 1039, 1039,
  1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039,
  1039, 1039, 1039,

  1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039,
  1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039,
  1039, 1039, 1039, 962, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039,
  1039, 1039, 1039, 1041, 1041, 1042, 1043, 1044, 1045, 1045, 1045, 1046, 1047, 1048, 962, 962,
  1049, 1050, 1050, 1050, 1050, 1050, 1050, 1050, 1050, 1051, 1052, 962, 1053, 1054, 1055, 1056,
  1039, 1039, 1039, 1040, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039,
  1039, 1039, 1039, 1039,

  1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039,
  1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039,
  1039, 1039, 962, 962, 962, 962, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039,
  1039, 1041, 1041, 1041, 1043, 1044, 1045, 1045, 1045, 962, 962, 1050, 1050, 1050, 1050, 1050,
  1050, 1050, 1050, 1052, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039,
  1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039,
  1039, 1039, 1039,

  1039, 1039, 1039, 1039, 1039, 1039, 962, 1039, 1039, 1039, 962, 1039, 1039, 1039, 962, 962, 962,
  962, 962, 962, 962, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1041, 1041, 1041,
  1045, 1045, 1045, 962, 962, 1050, 1050, 962, 962, 1050, 1050, 1050, 1050, 1050, 1050, 1039, 1039,
  1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039,
  1039, 1039, 1039, 1039, 962, 1039, 1039, 1039, 1039, 1039, 962, 1039, 962, 1039, 962, 1039, 1039,
  962, 962, 962, 1039, 1039, 1039, 962, 962, 962, 962, 962, 962, 1039, 1039, 1039, 1039,

  1039, 1039, 1041, 1041, 1041, 1045, 1045, 1045, 962, 962, 1050, 1050, 962, 962, 1050, 1050, 1050,
  1050, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 962, 1039, 962,
  1039, 1039, 1039, 962, 962, 962, 962, 962, 962, 1039, 1039, 1041, 1041, 1041, 1057, 1045, 1045,
  962, 962, 1050, 1050, 1039, 1039, 1039, 1039, 1039, 1039, 962, 1039, 962, 962, 962, 1039, 1039,
  1039, 962, 962, 962, 962, 962, 962, 1039, 1039, 1058, 1041, 1041, 1057, 1045, 1045, 962, 962,
  1039, 1039, 1039, 1039, 962, 962, 962, 1039, 1039, 1039, 962, 962, 962, 1059, 962, 1060,

  1039, 1039, 1058, 1041, 1041, 1045, 1045, 962, 1039, 1039, 1039, 1039, 962, 962, 962, 1039, 1039,
  1061, 962, 1062, 1063, 1039, 1039, 1041, 1041, 1064, 1045, 962, 1039, 1039, 962, 962, 962, 962,
  1039, 1039, 962, 1065, 1041, 1064, 1045, 962, 962, 962, 962, 1039, 1066, 1065, 1041, 1045, 962,
  962, 1039, 1041, 1067, 962, 962, 1039, 1068, 1067, 1068, 0, 962, 962, 962, 962, 962, 962, 962,
  962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962,
  962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962,

  962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962,
  962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962,
  962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962,
  962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962 };

static const flex_int16_t yy_nxt[2844] = { 0, 4, 5, 6, 7, 7, 5, 8, 9, 4, 10, 11, 12, 13, 14, 15, 16,
  14, 17, 18, 19, 20, 21, 21, 21, 21, 21, 21, 21, 22, 23, 24, 25, 4, 26, 27, 28, 27, 27, 27, 27, 27,
  27, 27, 27, 29, 27, 27, 27, 27, 30, 31, 27, 27, 32, 33, 27, 27, 34, 35, 36, 37, 38, 39, 40, 41,
  42, 43, 44, 27, 27, 45, 27, 46, 47, 48, 49, 50, 27, 51, 52, 53, 54, 55, 56, 57, 27, 27, 14, 58,
  14, 27, 59, 60, 65, 61, 59, 68, 65, 62, 70,

  73, 71, 72, 77, 77, 88, 77, 77, 86, 63, 94, 108, 78, 914, 109, 95, 79, 123, 89, 90, 74, 91, 64,
  87, 110, 92, 96, 93, 93, 93, 93, 93, 93, 93, 93, 80, 124, 82, 120, 104, 115, 116, 121, 111, 112,
  113, 98, 69, 105, 105, 105, 105, 105, 105, 105, 105, 83, 120, 129, 962, 130, 121, 150, 84, 97,
  107, 127, 127, 75, 127, 127, 98, 151, 99, 99, 99, 99, 99, 99, 99, 100, 122, 132, 138, 141, 139,
  143, 101, 133, 142, 102, 184, 140, 144, 107, 134, 145, 135, 147, 146,

  122, 136, 162, 152, 163, 164, 154, 148, 103, 153, 137, 155, 165, 68, 158, 166, 101, 149, 159, 102,
  168, 169, 128, 172, 120, 198, 173, 160, 121, 179, 170, 171, 915, 161, 180, 174, 193, 103, 200,
  181, 200, 194, 175, 176, 186, 187, 65, 187, 186, 185, 65, 188, 96, 203, 200, 211, 77, 77, 201, 77,
  77, 200, 189, 211, 69, 78, 202, 122, 207, 79, 220, 220, 76, 213, 285, 190, 286, 208, 208, 208,
  208, 208, 208, 208, 208, 68, 213, 204, 80, 916, 82, 177, 257, 258, 210, 200, 178, 99, 99, 99,

  99, 99, 99, 99, 100, 235, 269, 259, 265, 83, 260, 322, 266, 236, 270, 261, 84, 288, 127, 127, 276,
  127, 127, 210, 214, 214, 214, 214, 214, 214, 214, 214, 282, 97, 277, 289, 69, 283, 315, 316, 98,
  216, 99, 99, 99, 99, 99, 99, 99, 100, 366, 219, 291, 200, 302, 292, 303, 367, 98, 218, 100, 100,
  100, 100, 100, 100, 100, 100, 293, 917, 216, 323, 120, 221, 128, 221, 121, 102, 222, 222, 222,
  222, 222, 222, 222, 222, 437, 200, 218, 105, 105, 105, 105, 105, 105, 105, 105, 307, 104, 191,

  321, 309, 308, 377, 438, 98, 102, 105, 105, 105, 105, 105, 105, 105, 105, 122, 378, 78, 318, 191,
  221, 79, 221, 68, 107, 225, 225, 225, 225, 225, 225, 225, 225, 241, 298, 242, 243, 200, 244, 343,
  343, 186, 187, 299, 187, 186, 310, 245, 188, 246, 247, 248, 918, 107, 310, 192, 312, 313, 417,
  189, 208, 208, 208, 208, 208, 208, 208, 208, 342, 418, 313, 420, 190, 324, 69, 192, 325, 343, 343,
  432, 421, 207, 441, 314, 442, 200, 68, 432, 326, 327, 208, 208, 208, 208, 208, 208, 208, 208, 200,
  200,

  200, 448, 531, 329, 449, 329, 532, 210, 330, 330, 330, 330, 330, 330, 330, 330, 333, 100, 100,
  100, 100, 100, 100, 100, 100, 334, 334, 334, 334, 334, 334, 334, 334, 200, 452, 200, 210, 69, 338,
  454, 338, 567, 336, 339, 339, 339, 339, 339, 339, 339, 339, 221, 552, 221, 434, 435, 341, 341,
  341, 341, 341, 341, 341, 341, 501, 555, 502, 556, 435, 200, 553, 336, 222, 222, 222, 222, 222,
  222, 222, 222, 345, 436, 557, 200, 200, 453, 919, 558, 200, 346, 346, 346, 346, 346, 346, 346,
  346, 348, 200, 200,

  200, 566, 200, 746, 568, 200, 349, 349, 349, 349, 349, 349, 349, 349, 447, 812, 345, 200, 200,
  350, 350, 350, 350, 350, 350, 352, 352, 352, 352, 352, 352, 352, 352, 920, 342, 450, 542, 569,
  570, 572, 740, 661, 451, 343, 343, 543, 200, 200, 350, 350, 350, 350, 350, 350, 455, 455, 455,
  455, 455, 455, 455, 455, 456, 334, 334, 334, 334, 334, 334, 334, 334, 457, 457, 457, 457, 457,
  457, 457, 457, 333, 463, 463, 463, 463, 463, 463, 463, 463, 334, 334, 334, 334, 334, 334, 334,
  334, 200, 571, 668, 606,

  200, 461, 921, 461, 607, 336, 462, 462, 462, 462, 462, 462, 462, 462, 464, 346, 346, 346, 346,
  346, 346, 346, 346, 465, 465, 465, 465, 465, 465, 465, 465, 345, 651, 789, 336, 790, 664, 652,
  573, 345, 467, 467, 467, 467, 467, 467, 467, 467, 346, 346, 346, 346, 346, 346, 346, 346, 348,
  574, 574, 574, 574, 574, 574, 574, 574, 349, 349, 349, 349, 349, 349, 349, 349, 707, 707, 345,
  707, 707, 350, 350, 350, 350, 350, 350, 352, 352, 352, 352, 352, 352, 352, 352, 575, 575, 575,
  575, 575, 575, 575, 575,

  200, 200, 922, 200, 923, 456, 662, 350, 350, 350, 350, 350, 350, 348, 574, 574, 574, 574, 574,
  574, 574, 574, 471, 471, 471, 471, 471, 471, 471, 471, 200, 811, 456, 924, 748, 472, 472, 472,
  472, 472, 472, 457, 457, 457, 457, 457, 457, 457, 457, 579, 579, 579, 579, 579, 579, 579, 579,
  925, 926, 927, 928, 576, 200, 200, 472, 472, 472, 472, 472, 472, 577, 577, 577, 577, 577, 577,
  577, 577, 464, 929, 780, 780, 666, 780, 780, 930, 464, 579, 579, 579, 579, 579, 579, 579, 579,
  465, 465, 465, 465, 465,

  465, 465, 465, 345, 200, 200, 745, 815, 200, 931, 200, 200, 467, 467, 467, 467, 467, 467, 467,
  467, 348, 663, 200, 785, 785, 932, 785, 785, 718, 471, 471, 471, 471, 471, 471, 471, 471, 719,
  720, 935, 665, 667, 472, 472, 472, 472, 472, 472, 635, 456, 786, 936, 636, 637, 817, 745, 816,
  638, 574, 574, 574, 574, 574, 574, 574, 574, 937, 938, 939, 576, 941, 472, 472, 472, 472, 472,
  472, 348, 669, 669, 669, 669, 669, 669, 669, 669, 471, 471, 471, 471, 471, 471, 471, 471, 785,
  785, 942, 785, 785, 472,

  472, 472, 472, 472, 472, 669, 669, 669, 669, 669, 669, 669, 669, 200, 200, 200, 945, 946, 947,
  949, 741, 786, 950, 707, 707, 576, 707, 707, 472, 472, 472, 472, 472, 472, 577, 577, 577, 577,
  577, 577, 577, 577, 464, 864, 864, 951, 864, 864, 952, 818, 747, 579, 579, 579, 579, 579, 579,
  579, 579, 711, 711, 711, 711, 711, 711, 711, 711, 711, 711, 711, 711, 711, 711, 711, 711, 711,
  711, 711, 711, 712, 712, 712, 712, 712, 712, 712, 712, 711, 711, 711, 711, 711, 200, 742, 742,
  200, 742, 742, 576, 200,

  200, 782, 953, 954, 955, 884, 743, 669, 669, 669, 669, 669, 669, 669, 669, 958, 711, 711, 711,
  711, 200, 742, 742, 959, 742, 742, 780, 780, 749, 780, 780, 913, 813, 813, 743, 813, 813, 912,
  911, 853, 744, 910, 200, 745, 854, 814, 711, 711, 711, 712, 721, 721, 721, 721, 721, 721, 721,
  721, 721, 721, 721, 721, 721, 721, 721, 721, 721, 721, 721, 721, 722, 722, 722, 722, 722, 722,
  722, 722, 721, 721, 721, 721, 721, 200, 813, 813, 745, 813, 813, 742, 742, 909, 742, 742, 908,
  933, 933, 814, 933, 933,

  907, 906, 743, 905, 831, 904, 902, 721, 721, 721, 721, 200, 901, 900, 864, 864, 200, 864, 864,
  899, 898, 897, 934, 896, 895, 894, 893, 745, 892, 891, 889, 888, 887, 886, 885, 884, 744, 721,
  721, 721, 722, 772, 772, 772, 772, 772, 772, 772, 772, 772, 772, 772, 772, 772, 772, 772, 772,
  772, 772, 772, 772, 773, 773, 773, 773, 773, 773, 773, 773, 772, 772, 772, 772, 772, 883, 742,
  742, 882, 742, 742, 943, 943, 881, 943, 943, 879, 933, 933, 743, 933, 933, 878, 890, 943, 943,
  877, 943, 943, 772, 772,

  772, 772, 200, 876, 875, 874, 873, 944, 872, 871, 870, 869, 868, 934, 867, 866, 865, 863, 860,
  859, 944, 681, 744, 858, 681, 857, 856, 855, 772, 772, 772, 773, 778, 778, 778, 778, 778, 778,
  778, 778, 778, 778, 778, 778, 778, 778, 778, 778, 778, 778, 778, 778, 779, 779, 779, 779, 779,
  779, 779, 779, 778, 778, 778, 778, 778, 852, 956, 956, 851, 956, 956, 956, 956, 850, 956, 956,
  849, 848, 847, 846, 845, 844, 843, 842, 841, 840, 839, 838, 837, 778, 778, 778, 778, 957, 836,
  835, 834, 833, 957, 832,

  830, 829, 828, 827, 826, 825, 681, 824, 823, 822, 681, 821, 820, 819, 673, 673, 200, 810, 809,
  778, 778, 778, 779, 787, 787, 787, 787, 787, 787, 787, 787, 787, 787, 787, 787, 787, 787, 787,
  787, 787, 787, 787, 787, 788, 788, 788, 788, 788, 788, 788, 788, 787, 787, 787, 787, 787, 808,
  807, 806, 805, 804, 803, 802, 801, 800, 799, 798, 797, 796, 795, 794, 793, 792, 791, 784, 783,
  781, 777, 776, 775, 787, 787, 787, 787, 774, 771, 770, 769, 768, 767, 766, 765, 764, 763, 762,
  761, 760, 759, 758, 757,

  756, 755, 754, 753, 752, 751, 750, 739, 738, 737, 787, 787, 787, 788, 861, 861, 861, 861, 861,
  861, 861, 861, 861, 861, 861, 861, 861, 861, 861, 861, 861, 861, 861, 861, 862, 862, 862, 862,
  862, 862, 862, 862, 861, 861, 861, 861, 861, 736, 735, 734, 733, 732, 731, 730, 729, 728, 727,
  726, 725, 724, 723, 717, 716, 715, 714, 713, 710, 709, 708, 706, 705, 861, 861, 861, 861, 704,
  703, 702, 701, 700, 699, 698, 697, 696, 695, 694, 693, 692, 691, 690, 689, 688, 687, 686, 685,
  684, 683, 682, 681, 680,

  679, 861, 861, 861, 862, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 75, 75, 75, 75,
  75, 75, 678, 75, 75, 75, 75, 75, 75, 75, 81, 81, 677, 81, 81, 676, 675, 674, 673, 672, 81, 81, 81,
  106, 106, 106, 106, 671, 106, 106, 106, 117, 117, 670, 117, 117, 117, 191, 191, 660, 191, 191,
  191, 191, 191, 191, 191, 191, 191, 191, 191, 199, 199, 199, 199, 199, 199, 209, 659, 209, 209,
  658, 209, 209, 209, 212, 212, 657, 212, 212, 212, 212, 212, 212, 212, 212, 212,

  212, 212, 215, 215, 656, 215, 215, 215, 217, 217, 217, 217, 653, 217, 217, 217, 223, 223, 650,
  223, 224, 224, 649, 224, 224, 224, 232, 648, 647, 646, 232, 232, 232, 232, 232, 232, 232, 232,
  232, 232, 311, 311, 645, 311, 311, 311, 311, 311, 311, 311, 311, 311, 311, 311, 317, 317, 317,
  328, 328, 644, 328, 328, 328, 335, 643, 335, 335, 642, 335, 335, 335, 337, 337, 641, 337, 337,
  337, 340, 340, 640, 340, 340, 340, 344, 639, 344, 634, 633, 344, 344, 344, 347, 632, 347, 347,
  631, 347, 347, 347, 351,

  630, 351, 351, 629, 351, 351, 351, 353, 628, 353, 353, 627, 353, 353, 353, 433, 433, 626, 433,
  433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 439, 439, 625, 439, 439, 439, 439, 439, 439,
  439, 439, 439, 439, 439, 445, 445, 624, 445, 445, 445, 446, 446, 446, 81, 623, 622, 621, 620, 619,
  81, 81, 81, 199, 199, 199, 199, 199, 199, 458, 618, 458, 458, 617, 458, 458, 458, 459, 459, 616,
  459, 459, 459, 459, 459, 459, 459, 459, 459, 459, 459, 335, 615, 335, 335, 614, 335, 335, 335,
  460, 460, 613,

  460, 460, 460, 337, 337, 612, 337, 337, 337, 466, 611, 466, 466, 610, 466, 466, 466, 340, 340,
  609, 340, 340, 340, 468, 608, 468, 468, 605, 468, 468, 468, 344, 604, 344, 603, 602, 344, 344,
  344, 469, 469, 601, 469, 469, 469, 347, 600, 347, 347, 599, 347, 347, 347, 470, 470, 598, 470,
  470, 470, 349, 349, 597, 349, 351, 596, 351, 351, 595, 351, 351, 351, 473, 594, 473, 473, 593,
  473, 473, 473, 474, 474, 592, 474, 474, 474, 353, 591, 353, 353, 590, 353, 353, 353, 475, 475,
  589, 475, 475, 475, 117,

  117, 588, 117, 117, 117, 479, 479, 479, 433, 433, 587, 433, 433, 433, 433, 433, 433, 433, 433,
  433, 433, 433, 554, 554, 586, 554, 554, 554, 554, 554, 554, 554, 554, 554, 554, 554, 311, 311,
  585, 311, 311, 311, 311, 311, 311, 311, 311, 311, 311, 311, 439, 439, 583, 439, 439, 439, 439,
  439, 439, 439, 439, 439, 439, 439, 560, 560, 582, 560, 560, 560, 560, 560, 560, 560, 560, 560,
  560, 560, 561, 561, 581, 561, 561, 561, 561, 561, 561, 561, 561, 561, 561, 561, 562, 562, 564,
  562, 562, 562, 562, 562,

  562, 562, 562, 562, 562, 562, 445, 445, 563, 445, 445, 445, 565, 565, 559, 565, 565, 565, 199,
  199, 199, 199, 199, 199, 209, 551, 209, 209, 550, 209, 209, 209, 458, 549, 458, 458, 548, 458,
  458, 458, 328, 328, 547, 328, 328, 328, 459, 459, 546, 459, 459, 459, 459, 459, 459, 459, 459,
  459, 459, 459, 460, 460, 545, 460, 460, 460, 578, 544, 578, 578, 541, 578, 578, 578, 215, 540,
  215, 215, 539, 215, 215, 215, 466, 538, 466, 466, 537, 466, 466, 466, 337, 337, 536, 337, 337,
  337, 468, 535, 468, 468,

  534, 468, 468, 468, 580, 580, 533, 580, 580, 580, 469, 469, 530, 469, 469, 469, 470, 470, 529,
  470, 470, 470, 473, 528, 473, 473, 527, 473, 473, 473, 474, 474, 526, 474, 474, 474, 475, 475,
  525, 475, 475, 475, 117, 117, 524, 117, 117, 117, 584, 584, 523, 584, 584, 584, 433, 433, 522,
  433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 554, 554, 521, 554, 554, 554, 554, 554,
  554, 554, 554, 554, 554, 554, 654, 654, 520, 654, 654, 654, 654, 654, 654, 654, 654, 654, 654,
  654, 655, 655, 519, 655,

  655, 655, 655, 655, 655, 655, 655, 655, 655, 655, 311, 311, 518, 311, 311, 311, 311, 311, 311,
  311, 311, 311, 311, 311, 560, 560, 517, 560, 560, 560, 560, 560, 560, 560, 560, 560, 560, 560,
  561, 561, 516, 561, 561, 561, 561, 561, 561, 561, 561, 561, 561, 561, 562, 562, 515, 562, 562,
  562, 562, 562, 562, 562, 562, 562, 562, 562, 565, 565, 514, 565, 565, 565, 199, 199, 199, 199,
  199, 199, 209, 513, 209, 209, 512, 209, 209, 209, 335, 511, 335, 335, 510, 335, 335, 335, 578,
  509, 578, 578, 508, 578,

  578, 578, 460, 460, 507, 460, 460, 460, 215, 506, 215, 215, 505, 215, 215, 215, 580, 580, 504,
  580, 580, 580, 880, 880, 503, 880, 880, 880, 880, 880, 880, 880, 880, 880, 880, 880, 903, 903,
  500, 903, 903, 903, 903, 903, 903, 903, 903, 903, 903, 903, 711, 711, 711, 711, 711, 711, 711,
  711, 711, 711, 711, 499, 498, 711, 721, 721, 721, 721, 721, 721, 721, 721, 721, 721, 721, 497,
  496, 721, 772, 772, 772, 772, 772, 772, 772, 772, 772, 772, 772, 495, 494, 772, 778, 778, 778,
  778, 778, 778, 778, 778,

  778, 778, 778, 493, 492, 778, 787, 787, 787, 787, 787, 787, 787, 787, 787, 787, 787, 491, 490,
  787, 940, 940, 489, 940, 940, 940, 940, 940, 940, 940, 940, 940, 940, 940, 948, 948, 488, 948,
  948, 948, 948, 948, 948, 948, 948, 948, 948, 948, 861, 861, 861, 861, 861, 861, 861, 861, 861,
  861, 861, 487, 486, 861, 960, 960, 485, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960,
  961, 961, 484, 961, 961, 961, 961, 961, 961, 961, 961, 961, 961, 961, 483, 482, 481, 480, 478,
  477, 476, 444, 443, 440,

  331, 431, 430, 429, 428, 427, 426, 425, 424, 423, 422, 419, 416, 415, 414, 413, 412, 411, 410,
  409, 408, 407, 406, 405, 404, 403, 402, 401, 400, 399, 398, 397, 396, 395, 394, 393, 392, 391,
  390, 389, 388, 387, 386, 385, 384, 383, 382, 381, 380, 379, 376, 375, 374, 373, 372, 371, 370,
  369, 368, 365, 364, 363, 362, 361, 360, 359, 358, 233, 357, 356, 355, 354, 332, 331, 320, 200,
  319, 192, 195, 192, 306, 305, 304, 301, 300, 297, 296, 295, 294, 290, 287, 284, 281, 280, 279,
  278, 275, 274, 273, 272,

  271, 268, 267, 264, 263, 262, 256, 255, 254, 253, 252, 251, 250, 249, 240, 239, 238, 237, 129,
  234, 233, 231, 230, 125, 76, 229, 228, 227, 226, 206, 205, 200, 197, 196, 195, 192, 183, 182, 167,
  157, 156, 131, 126, 125, 119, 118, 114, 85, 76, 66, 962, 3, 962, 962, 962, 962, 962, 962, 962,
  962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962,
  962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962,
  962, 962, 962,

  962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962,
  962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962,
  962, 962, 962, 962, 962 };

static const flex_int16_t yy_chk[2844] = { 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 2, 2, 5, 2, 2, 9, 5, 2, 10,

  11, 10, 10, 13, 13, 17, 13, 13, 16, 2, 19, 22, 13, 890, 22, 19, 13, 30, 17, 17, 11, 18, 2, 16, 23,
  18, 19, 18, 18, 18, 18, 18, 18, 18, 18, 13, 30, 13, 29, 21, 25, 25, 29, 23, 23, 23, 21, 9, 21, 21,
  21, 21, 21, 21, 21, 21, 13, 32, 35, 76, 35, 32, 43, 13, 20, 21, 34, 34, 76, 34, 34, 20, 43, 20,
  20, 20, 20, 20, 20, 20, 20, 29, 38, 39, 40, 39, 41, 20, 38, 40, 20, 58, 39, 41, 21, 38, 41, 38,
  42, 41,

  32, 38, 49, 44, 49, 49, 45, 42, 20, 44, 38, 45, 50, 67, 48, 50, 20, 42, 48, 20, 52, 52, 34, 53,
  54, 75, 53, 48, 54, 55, 52, 52, 891, 48, 55, 53, 63, 20, 80, 55, 83, 63, 53, 54, 59, 59, 65, 59,
  59, 58, 65, 59, 63, 83, 84, 94, 77, 77, 80, 77, 77, 82, 59, 94, 67, 77, 82, 54, 93, 77, 101, 101,
  75, 95, 167, 59, 167, 93, 93, 93, 93, 93, 93, 93, 93, 120, 95, 84, 77, 892, 77, 54, 146, 146, 93,
  202, 54, 97, 97, 97,

  97, 97, 97, 97, 97, 132, 154, 147, 151, 77, 147, 202, 151, 132, 154, 147, 77, 169, 127, 127, 160,
  127, 127, 93, 98, 98, 98, 98, 98, 98, 98, 98, 165, 99, 160, 169, 120, 165, 195, 195, 99, 98, 99,
  99, 99, 99, 99, 99, 99, 99, 242, 100, 171, 203, 180, 171, 180, 242, 100, 99, 100, 100, 100, 100,
  100, 100, 100, 100, 171, 893, 98, 203, 176, 102, 127, 102, 176, 100, 102, 102, 102, 102, 102, 102,
  102, 102, 312, 201, 99, 104, 104, 104, 104, 104, 104, 104, 104, 189, 105, 192,

  201, 192, 189, 252, 312, 105, 100, 105, 105, 105, 105, 105, 105, 105, 105, 176, 252, 320, 197,
  309, 107, 320, 107, 197, 105, 107, 107, 107, 107, 107, 107, 107, 107, 137, 177, 137, 137, 204,
  137, 342, 342, 186, 186, 177, 186, 186, 193, 137, 186, 137, 137, 137, 895, 105, 193, 192, 194,
  194, 293, 186, 207, 207, 207, 207, 207, 207, 207, 207, 220, 293, 194, 295, 186, 204, 197, 309,
  204, 220, 220, 307, 295, 208, 314, 194, 314, 322, 318, 307, 204, 204, 208, 208, 208, 208, 208,
  208, 208, 208, 327, 323,

  325, 322, 412, 210, 323, 210, 412, 208, 210, 210, 210, 210, 210, 210, 210, 210, 214, 219, 219,
  219, 219, 219, 219, 219, 219, 214, 214, 214, 214, 214, 214, 214, 214, 326, 325, 448, 208, 318,
  216, 327, 216, 448, 214, 216, 216, 216, 216, 216, 216, 216, 216, 218, 434, 218, 308, 308, 218,
  218, 218, 218, 218, 218, 218, 218, 381, 436, 381, 436, 308, 665, 434, 214, 221, 221, 221, 221,
  221, 221, 221, 221, 222, 308, 437, 447, 449, 326, 896, 437, 451, 222, 222, 222, 222, 222, 222,
  222, 222, 223, 324, 450,

  741, 447, 453, 665, 449, 321, 223, 223, 223, 223, 223, 223, 223, 223, 321, 741, 225, 566, 661,
  223, 223, 223, 223, 223, 223, 225, 225, 225, 225, 225, 225, 225, 225, 897, 343, 324, 422, 450,
  451, 453, 661, 566, 324, 343, 343, 422, 452, 573, 223, 223, 223, 223, 223, 223, 329, 329, 329,
  329, 329, 329, 329, 329, 330, 333, 333, 333, 333, 333, 333, 333, 333, 330, 330, 330, 330, 330,
  330, 330, 330, 334, 338, 338, 338, 338, 338, 338, 338, 338, 334, 334, 334, 334, 334, 334, 334,
  334, 454, 452, 573, 505,

  569, 336, 899, 336, 505, 334, 336, 336, 336, 336, 336, 336, 336, 336, 339, 345, 345, 345, 345,
  345, 345, 345, 345, 339, 339, 339, 339, 339, 339, 339, 339, 341, 552, 714, 334, 714, 569, 552,
  454, 346, 341, 341, 341, 341, 341, 341, 341, 341, 346, 346, 346, 346, 346, 346, 346, 346, 349,
  456, 456, 456, 456, 456, 456, 456, 456, 349, 349, 349, 349, 349, 349, 349, 349, 627, 627, 352,
  627, 627, 349, 349, 349, 349, 349, 349, 352, 352, 352, 352, 352, 352, 352, 352, 461, 461, 461,
  461, 461, 461, 461, 461,

  667, 567, 901, 740, 902, 455, 567, 349, 349, 349, 349, 349, 349, 350, 455, 455, 455, 455, 455,
  455, 455, 455, 350, 350, 350, 350, 350, 350, 350, 350, 571, 740, 457, 904, 667, 350, 350, 350,
  350, 350, 350, 457, 457, 457, 457, 457, 457, 457, 457, 464, 464, 464, 464, 464, 464, 464, 464,
  905, 906, 907, 908, 462, 664, 746, 350, 350, 350, 350, 350, 350, 462, 462, 462, 462, 462, 462,
  462, 462, 463, 909, 705, 705, 571, 705, 705, 910, 465, 463, 463, 463, 463, 463, 463, 463, 463,
  465, 465, 465, 465, 465,

  465, 465, 465, 467, 570, 572, 664, 746, 568, 913, 748, 815, 467, 467, 467, 467, 467, 467, 467,
  467, 471, 568, 747, 710, 710, 914, 710, 710, 638, 471, 471, 471, 471, 471, 471, 471, 471, 638,
  638, 916, 570, 572, 471, 471, 471, 471, 471, 471, 536, 574, 710, 917, 536, 536, 748, 815, 747,
  536, 574, 574, 574, 574, 574, 574, 574, 574, 919, 924, 925, 575, 927, 471, 471, 471, 471, 471,
  471, 472, 575, 575, 575, 575, 575, 575, 575, 575, 472, 472, 472, 472, 472, 472, 472, 472, 785,
  785, 928, 785, 785, 472,

  472, 472, 472, 472, 472, 576, 576, 576, 576, 576, 576, 576, 576, 662, 666, 749, 932, 935, 937,
  939, 662, 785, 941, 707, 707, 577, 707, 707, 472, 472, 472, 472, 472, 472, 577, 577, 577, 577,
  577, 577, 577, 577, 579, 832, 832, 942, 832, 832, 945, 749, 666, 579, 579, 579, 579, 579, 579,
  579, 579, 632, 632, 632, 632, 632, 632, 632, 632, 632, 632, 632, 632, 632, 632, 632, 632, 632,
  632, 632, 632, 632, 632, 632, 632, 632, 632, 632, 632, 632, 632, 632, 632, 632, 668, 663, 663,
  816, 663, 663, 669, 817,

  818, 707, 946, 949, 950, 951, 663, 669, 669, 669, 669, 669, 669, 669, 669, 953, 632, 632, 632,
  632, 663, 742, 742, 954, 742, 742, 780, 780, 668, 780, 780, 889, 813, 813, 742, 813, 813, 888,
  887, 816, 663, 886, 853, 817, 818, 813, 632, 632, 632, 632, 639, 639, 639, 639, 639, 639, 639,
  639, 639, 639, 639, 639, 639, 639, 639, 639, 639, 639, 639, 639, 639, 639, 639, 639, 639, 639,
  639, 639, 639, 639, 639, 639, 639, 854, 745, 745, 853, 745, 745, 811, 811, 885, 811, 811, 883,
  915, 915, 745, 915, 915,

  882, 881, 811, 879, 780, 878, 876, 639, 639, 639, 639, 745, 875, 874, 864, 864, 811, 864, 864,
  873, 872, 871, 915, 870, 869, 868, 867, 854, 866, 865, 863, 860, 858, 856, 855, 852, 811, 639,
  639, 639, 639, 698, 698, 698, 698, 698, 698, 698, 698, 698, 698, 698, 698, 698, 698, 698, 698,
  698, 698, 698, 698, 698, 698, 698, 698, 698, 698, 698, 698, 698, 698, 698, 698, 698, 851, 812,
  812, 850, 812, 812, 931, 931, 849, 931, 931, 847, 933, 933, 812, 933, 933, 846, 864, 943, 943,
  845, 943, 943, 698, 698,

  698, 698, 812, 844, 843, 842, 841, 931, 840, 839, 838, 837, 836, 933, 835, 834, 833, 831, 828,
  826, 943, 825, 812, 824, 823, 822, 821, 820, 698, 698, 698, 698, 704, 704, 704, 704, 704, 704,
  704, 704, 704, 704, 704, 704, 704, 704, 704, 704, 704, 704, 704, 704, 704, 704, 704, 704, 704,
  704, 704, 704, 704, 704, 704, 704, 704, 810, 952, 952, 809, 952, 952, 956, 956, 808, 956, 956,
  807, 806, 805, 804, 803, 802, 798, 796, 795, 794, 793, 792, 791, 704, 704, 704, 704, 952, 790,
  789, 784, 782, 956, 781,

  776, 774, 770, 768, 767, 764, 763, 762, 760, 759, 758, 757, 756, 755, 751, 750, 744, 739, 738,
  704, 704, 704, 704, 713, 713, 713, 713, 713, 713, 713, 713, 713, 713, 713, 713, 713, 713, 713,
  713, 713, 713, 713, 713, 713, 713, 713, 713, 713, 713, 713, 713, 713, 713, 713, 713, 713, 737,
  736, 735, 734, 733, 732, 730, 729, 727, 726, 724, 723, 720, 719, 718, 717, 716, 715, 709, 708,
  706, 703, 702, 701, 713, 713, 713, 713, 700, 697, 696, 694, 693, 692, 691, 690, 688, 687, 686,
  685, 684, 683, 682, 680,

  679, 677, 676, 674, 672, 671, 670, 660, 659, 658, 713, 713, 713, 713, 830, 830, 830, 830, 830,
  830, 830, 830, 830, 830, 830, 830, 830, 830, 830, 830, 830, 830, 830, 830, 830, 830, 830, 830,
  830, 830, 830, 830, 830, 830, 830, 830, 830, 657, 656, 653, 652, 651, 649, 648, 647, 646, 645,
  644, 643, 642, 641, 637, 636, 635, 634, 633, 630, 629, 628, 626, 625, 830, 830, 830, 830, 624,
  623, 622, 620, 619, 618, 617, 613, 612, 609, 608, 607, 606, 605, 604, 601, 600, 599, 598, 597,
  596, 595, 594, 593, 592,

  591, 830, 830, 830, 830, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963, 963,
  964, 964, 964, 964, 964, 964, 590, 964, 964, 964, 964, 964, 964, 964, 965, 965, 589, 965, 965,
  588, 587, 586, 585, 583, 965, 965, 965, 966, 966, 966, 966, 582, 966, 966, 966, 967, 967, 581,
  967, 967, 967, 968, 968, 564, 968, 968, 968, 968, 968, 968, 968, 968, 968, 968, 968, 969, 969,
  969, 969, 969, 969, 970, 563, 970, 970, 559, 970, 970, 970, 971, 971, 558, 971, 971, 971, 971,
  971, 971, 971, 971, 971,

  971, 971, 972, 972, 557, 972, 972, 972, 973, 973, 973, 973, 553, 973, 973, 973, 974, 974, 551,
  974, 975, 975, 550, 975, 975, 975, 976, 549, 548, 547, 976, 976, 976, 976, 976, 976, 976, 976,
  976, 976, 977, 977, 545, 977, 977, 977, 977, 977, 977, 977, 977, 977, 977, 977, 978, 978, 978,
  979, 979, 543, 979, 979, 979, 980, 542, 980, 980, 540, 980, 980, 980, 981, 981, 539, 981, 981,
  981, 982, 982, 538, 982, 982, 982, 983, 537, 983, 535, 534, 983, 983, 983, 984, 533, 984, 984,
  532, 984, 984, 984, 985,

  531, 985, 985, 529, 985, 985, 985, 986, 528, 986, 986, 527, 986, 986, 986, 987, 987, 526, 987,
  987, 987, 987, 987, 987, 987, 987, 987, 987, 987, 988, 988, 525, 988, 988, 988, 988, 988, 988,
  988, 988, 988, 988, 988, 989, 989, 524, 989, 989, 989, 990, 990, 990, 991, 522, 521, 520, 519,
  518, 991, 991, 991, 992, 992, 992, 992, 992, 992, 993, 517, 993, 993, 516, 993, 993, 993, 994,
  994, 515, 994, 994, 994, 994, 994, 994, 994, 994, 994, 994, 994, 995, 514, 995, 995, 512, 995,
  995, 995, 996, 996, 511,

  996, 996, 996, 997, 997, 510, 997, 997, 997, 998, 509, 998, 998, 508, 998, 998, 998, 999, 999,
  507, 999, 999, 999, 1000, 506, 1000, 1000, 502, 1000, 1000, 1000, 1001, 501, 1001, 498, 497, 1001,
  1001, 1001, 1002, 1002, 496, 1002, 1002, 1002, 1003, 495, 1003, 1003, 494, 1003, 1003, 1003, 1004,
  1004, 493, 1004, 1004, 1004, 1005, 1005, 492, 1005, 1006, 491, 1006, 1006, 490, 1006, 1006, 1006,
  1007, 489, 1007, 1007, 488, 1007, 1007, 1007, 1008, 1008, 487, 1008, 1008, 1008, 1009, 486, 1009,
  1009, 485, 1009, 1009, 1009, 1010, 1010, 484, 1010, 1010, 1010, 1011,

  1011, 483, 1011, 1011, 1011, 1012, 1012, 1012, 1013, 1013, 482, 1013, 1013, 1013, 1013, 1013,
  1013, 1013, 1013, 1013, 1013, 1013, 1014, 1014, 481, 1014, 1014, 1014, 1014, 1014, 1014, 1014,
  1014, 1014, 1014, 1014, 1015, 1015, 480, 1015, 1015, 1015, 1015, 1015, 1015, 1015, 1015, 1015,
  1015, 1015, 1016, 1016, 478, 1016, 1016, 1016, 1016, 1016, 1016, 1016, 1016, 1016, 1016, 1016,
  1017, 1017, 477, 1017, 1017, 1017, 1017, 1017, 1017, 1017, 1017, 1017, 1017, 1017, 1018, 1018,
  476, 1018, 1018, 1018, 1018, 1018, 1018, 1018, 1018, 1018, 1018, 1018, 1019, 1019, 444, 1019,
  1019, 1019, 1019, 1019,

  1019, 1019, 1019, 1019, 1019, 1019, 1020, 1020, 443, 1020, 1020, 1020, 1021, 1021, 438, 1021,
  1021, 1021, 1022, 1022, 1022, 1022, 1022, 1022, 1023, 431, 1023, 1023, 430, 1023, 1023, 1023,
  1024, 429, 1024, 1024, 428, 1024, 1024, 1024, 1025, 1025, 426, 1025, 1025, 1025, 1026, 1026, 425,
  1026, 1026, 1026, 1026, 1026, 1026, 1026, 1026, 1026, 1026, 1026, 1027, 1027, 424, 1027, 1027,
  1027, 1028, 423, 1028, 1028, 421, 1028, 1028, 1028, 1029, 420, 1029, 1029, 419, 1029, 1029, 1029,
  1030, 418, 1030, 1030, 417, 1030, 1030, 1030, 1031, 1031, 416, 1031, 1031, 1031, 1032, 415, 1032,
  1032,

  414, 1032, 1032, 1032, 1033, 1033, 413, 1033, 1033, 1033, 1034, 1034, 411, 1034, 1034, 1034, 1035,
  1035, 410, 1035, 1035, 1035, 1036, 409, 1036, 1036, 408, 1036, 1036, 1036, 1037, 1037, 407, 1037,
  1037, 1037, 1038, 1038, 406, 1038, 1038, 1038, 1039, 1039, 405, 1039, 1039, 1039, 1040, 1040, 404,
  1040, 1040, 1040, 1041, 1041, 403, 1041, 1041, 1041, 1041, 1041, 1041, 1041, 1041, 1041, 1041,
  1041, 1042, 1042, 402, 1042, 1042, 1042, 1042, 1042, 1042, 1042, 1042, 1042, 1042, 1042, 1043,
  1043, 401, 1043, 1043, 1043, 1043, 1043, 1043, 1043, 1043, 1043, 1043, 1043, 1044, 1044, 400,
  1044,

  1044, 1044, 1044, 1044, 1044, 1044, 1044, 1044, 1044, 1044, 1045, 1045, 399, 1045, 1045, 1045,
  1045, 1045, 1045, 1045, 1045, 1045, 1045, 1045, 1046, 1046, 398, 1046, 1046, 1046, 1046, 1046,
  1046, 1046, 1046, 1046, 1046, 1046, 1047, 1047, 396, 1047, 1047, 1047, 1047, 1047, 1047, 1047,
  1047, 1047, 1047, 1047, 1048, 1048, 395, 1048, 1048, 1048, 1048, 1048, 1048, 1048, 1048, 1048,
  1048, 1048, 1049, 1049, 394, 1049, 1049, 1049, 1050, 1050, 1050, 1050, 1050, 1050, 1051, 393,
  1051, 1051, 392, 1051, 1051, 1051, 1052, 391, 1052, 1052, 389, 1052, 1052, 1052, 1053, 388, 1053,
  1053, 387, 1053,

  1053, 1053, 1054, 1054, 386, 1054, 1054, 1054, 1055, 385, 1055, 1055, 384, 1055, 1055, 1055, 1056,
  1056, 383, 1056, 1056, 1056, 1057, 1057, 382, 1057, 1057, 1057, 1057, 1057, 1057, 1057, 1057,
  1057, 1057, 1057, 1058, 1058, 380, 1058, 1058, 1058, 1058, 1058, 1058, 1058, 1058, 1058, 1058,
  1058, 1059, 1059, 1059, 1059, 1059, 1059, 1059, 1059, 1059, 1059, 1059, 378, 377, 1059, 1060,
  1060, 1060, 1060, 1060, 1060, 1060, 1060, 1060, 1060, 1060, 375, 374, 1060, 1061, 1061, 1061,
  1061, 1061, 1061, 1061, 1061, 1061, 1061, 1061, 373, 372, 1061, 1062, 1062, 1062, 1062, 1062,
  1062, 1062, 1062,

  1062, 1062, 1062, 371, 370, 1062, 1063, 1063, 1063, 1063, 1063, 1063, 1063, 1063, 1063, 1063,
  1063, 369, 368, 1063, 1064, 1064, 367, 1064, 1064, 1064, 1064, 1064, 1064, 1064, 1064, 1064, 1064,
  1064, 1065, 1065, 366, 1065, 1065, 1065, 1065, 1065, 1065, 1065, 1065, 1065, 1065, 1065, 1066,
  1066, 1066, 1066, 1066, 1066, 1066, 1066, 1066, 1066, 1066, 365, 364, 1066, 1067, 1067, 363, 1067,
  1067, 1067, 1067, 1067, 1067, 1067, 1067, 1067, 1067, 1067, 1068, 1068, 362, 1068, 1068, 1068,
  1068, 1068, 1068, 1068, 1068, 1068, 1068, 1068, 361, 360, 359, 358, 356, 355, 354, 316, 315, 313,

  310, 306, 305, 304, 303, 302, 301, 300, 299, 298, 297, 294, 292, 291, 290, 289, 288, 287, 286,
  285, 284, 283, 282, 281, 280, 279, 278, 277, 276, 274, 273, 272, 271, 269, 268, 267, 266, 265,
  264, 263, 262, 261, 260, 259, 258, 257, 256, 255, 254, 253, 251, 250, 249, 248, 247, 246, 245,
  244, 243, 241, 240, 239, 238, 237, 236, 235, 234, 232, 231, 230, 229, 228, 213, 211, 200, 199,
  198, 191, 190, 188, 183, 182, 181, 179, 178, 175, 174, 173, 172, 170, 168, 166, 164, 163, 162,
  161, 159, 158, 157, 156,

  155, 153, 152, 150, 149, 148, 145, 144, 143, 142, 141, 140, 139, 138, 136, 135, 134, 133, 130,
  126, 125, 124, 123, 122, 121, 119, 118, 116, 112, 92, 90, 81, 69, 68, 64, 62, 57, 56, 51, 47, 46,
  37, 33, 31, 28, 26, 24, 15, 12, 8, 3, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962,
  962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962,
  962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962,

  962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962,
  962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962, 962,
  962, 962, 962, 962, 962 };

/* Table of booleans, true if rule could match eol. */
static const flex_int32_t yy_rule_can_match_eol[165] = {
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  0,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  0,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
};

static yy_state_type yy_last_accepting_state;
static char* yy_last_accepting_cpos;

extern int yy_flex_debug;
int yy_flex_debug = 0;

/* The intent behind this definition is that it'll catch
 * any uses of REJECT which flex missed.
 */
#define REJECT reject_used_but_not_detected
#define yymore() yymore_used_but_not_detected
#define YY_MORE_ADJ 0
#define YY_RESTORE_YY_MORE_OFFSET
char* yytext;

/*

This file must be translated to C and modified to build everywhere.

See the adjacent README.txt file for instructions.

*/

/* to workaround https://bugs.llvm.org/show_bug.cgi?id=43465 */
#if defined(__clang__)
#pragma clang diagnostic push
#if defined(__has_warning)
#if __has_warning("-Wimplicit-fallthrough")
#pragma clang diagnostic ignored "-Wimplicit-fallthrough"
#endif
#endif
#elif defined(__GNUC__) && (__GNUC__ >= 7)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wimplicit-fallthrough"
#endif

/* We do not care of interactive mode */
#define YY_NEVER_INTERACTIVE 1

/* Do not include unistd.h in generated source. */
#define YY_NO_UNISTD_H

/* Skip declaring this function.  It is a macro.  */
#define YY_SKIP_YYWRAP

#ifdef _WIN32
#pragma warning(disable : 4018)
#pragma warning(disable : 4127)
#pragma warning(disable : 4131)
#pragma warning(disable : 4244)
#pragma warning(disable : 4251)
#pragma warning(disable : 4267)
#pragma warning(disable : 4305)
#pragma warning(disable : 4309)
#pragma warning(disable : 4706)
#pragma warning(disable : 4786)
#endif

#define SKIP_MATCH_MAXLEN 15

/*
 * Skip ahead until one of the strings is found,
 * then skip to the end of the line.
 * Return 0 if no match found.
 */
static int skip_comment(void);
static int skip_trailing_comment(const char* text, size_t l);
static int skip_ahead_multi(const char* strings[]);
static int skip_ahead_until(const char* text);
static int skip_to_next_directive(void);
static int skip_conditional_block(void);

static void doxygen_comment(void);
static void doxygen_cpp_comment(void);
static void doxygen_group_start(void);
static void doxygen_group_end(void);
static void vtk_comment(void);
static void vtk_name_comment(void);
static void vtk_section_comment(void);
static void cpp_comment_line(void);
static void blank_line(void);

static const char* raw_string(const char* begin);

static void preprocessor_directive(const char* text, size_t l);
static void print_preprocessor_error(int result, const char* cp, size_t n);
static char* get_macro_arguments(void);
static void skip_macro_arguments(void);

static void push_buffer(void);
static int pop_buffer(void);

static void push_include(const char* filename);
static void pop_include(void);

static void push_macro(MacroInfo* macro);
static void pop_macro(void);
static int in_macro(void);

#define INITIAL 0

#ifndef YY_NO_UNISTD_H
/* Special case for "unistd.h", since it is non-ANSI. We include it way
 * down here because we want the user's section 1 to have been scanned first.
 * The user has a chance to override it with an option.
 */
#include <unistd.h>
#endif

#ifndef YY_EXTRA_TYPE
#define YY_EXTRA_TYPE void*
#endif

static int yy_init_globals(void);

/* Accessor methods to globals.
   These are made visible to non-reentrant scanners for convenience. */

int yylex_destroy(void);

int yyget_debug(void);

void yyset_debug(int debug_flag);

YY_EXTRA_TYPE yyget_extra(void);

void yyset_extra(YY_EXTRA_TYPE user_defined);

FILE* yyget_in(void);

void yyset_in(FILE* _in_str);

FILE* yyget_out(void);

void yyset_out(FILE* _out_str);

int yyget_leng(void);

char* yyget_text(void);

int yyget_lineno(void);

void yyset_lineno(int _line_number);

/* Macros after this point can all be overridden by user definitions in
 * section 1.
 */

#ifndef YY_SKIP_YYWRAP
#ifdef __cplusplus
extern "C" int yywrap(void);
#else
extern int yywrap(void);
#endif
#endif

#ifndef YY_NO_UNPUT

static void yyunput(int c, char* buf_ptr);

#endif

#ifndef yytext_ptr
static void yy_flex_strncpy(char*, const char*, int);
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen(const char*);
#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
static int yyinput(void);
#else
static int input(void);
#endif

#endif

/* Amount of stuff to slurp up with each read. */
#ifndef YY_READ_BUF_SIZE
#ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k */
#define YY_READ_BUF_SIZE 16384
#else
#define YY_READ_BUF_SIZE 8192
#endif /* __ia64__ */
#endif

/* Copy whatever the last rule matched to the standard output. */
#ifndef ECHO
/* This used to be an fputs(), but since the string might contain NUL's,
 * we now use fwrite().
 */
#define ECHO                                                                                       \
  do                                                                                               \
  {                                                                                                \
    if (fwrite(yytext, (size_t)yyleng, 1, yyout))                                                  \
    {                                                                                              \
    }                                                                                              \
  } while (0)
#endif

/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
 * is returned in "result".
 */
#ifndef YY_INPUT
#define YY_INPUT(buf, result, max_size)                                                            \
  if (YY_CURRENT_BUFFER_LVALUE->yy_is_interactive)                                                 \
  {                                                                                                \
    int c = '*';                                                                                   \
    int n;                                                                                         \
    for (n = 0; n < max_size && (c = getc(yyin)) != EOF && c != '\n'; ++n)                         \
      buf[n] = (char)c;                                                                            \
    if (c == '\n')                                                                                 \
      buf[n++] = (char)c;                                                                          \
    if (c == EOF && ferror(yyin))                                                                  \
      YY_FATAL_ERROR("input in flex scanner failed");                                              \
    result = n;                                                                                    \
  }                                                                                                \
  else                                                                                             \
  {                                                                                                \
    errno = 0;                                                                                     \
    while ((result = (int)fread(buf, 1, (yy_size_t)max_size, yyin)) == 0 && ferror(yyin))          \
    {                                                                                              \
      if (errno != EINTR)                                                                          \
      {                                                                                            \
        YY_FATAL_ERROR("input in flex scanner failed");                                            \
        break;                                                                                     \
      }                                                                                            \
      errno = 0;                                                                                   \
      clearerr(yyin);                                                                              \
    }                                                                                              \
  }

#endif

/* No semi-colon after return; correct usage is to write "yyterminate();" -
 * we don't want an extra ';' after the "return" because that will cause
 * some compilers to complain about unreachable statements.
 */
#ifndef yyterminate
#define yyterminate() return YY_NULL
#endif

/* Number of entries by which start-condition stack grows. */
#ifndef YY_START_STACK_INCR
#define YY_START_STACK_INCR 25
#endif

/* Report a fatal error. */
#ifndef YY_FATAL_ERROR
#define YY_FATAL_ERROR(msg) yy_fatal_error(msg)
#endif

/* end tables serialization structures and prototypes */

/* Default declaration of generated scanner - a define so the user can
 * easily add parameters.
 */
#ifndef YY_DECL
#define YY_DECL_IS_OURS 1

extern int yylex(void);

#define YY_DECL int yylex(void)
#endif /* !YY_DECL */

/* Code executed at the beginning of each rule, after yytext and yyleng
 * have been set up.
 */
#ifndef YY_USER_ACTION
#define YY_USER_ACTION
#endif

/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#define YY_BREAK /*LINTED*/ break;
#endif

#define YY_RULE_SETUP                                                                              \
  if (yyleng > 0)                                                                                  \
    YY_CURRENT_BUFFER_LVALUE->yy_at_bol = (yytext[yyleng - 1] == '\n');                            \
  YY_USER_ACTION

/** The main scanner function which does all the work.
 */
YY_DECL
{
  yy_state_type yy_current_state;
  char *yy_cp, *yy_bp;
  int yy_act;

  if (!(yy_init))
  {
    (yy_init) = 1;

#ifdef YY_USER_INIT
    YY_USER_INIT;
#endif

    if (!(yy_start))
      (yy_start) = 1; /* first start state */

    if (!yyin)
      yyin = stdin;

    if (!yyout)
      yyout = stdout;

    if (!YY_CURRENT_BUFFER)
    {
      yyensure_buffer_stack();
      YY_CURRENT_BUFFER_LVALUE = yy_create_buffer(yyin, YY_BUF_SIZE);
    }

    yy_load_buffer_state();
  }

  {

    while (/*CONSTCOND*/ 1) /* loops until end-of-file is reached */
    {
      yy_cp = (yy_c_buf_p);

      /* Support of yytext. */
      *yy_cp = (yy_hold_char);

      /* yy_bp points to the position in yy_ch_buf of the start of
       * the current run.
       */
      yy_bp = yy_cp;

      yy_current_state = (yy_start);
      yy_current_state += YY_AT_BOL();
    yy_match:
      do
      {
        YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
        if (yy_accept[yy_current_state])
        {
          (yy_last_accepting_state) = yy_current_state;
          (yy_last_accepting_cpos) = yy_cp;
        }
        while (yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state)
        {
          yy_current_state = (int)yy_def[yy_current_state];
          if (yy_current_state >= 963)
            yy_c = yy_meta[yy_c];
        }
        yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
        ++yy_cp;
      } while (yy_base[yy_current_state] != 2752);

    yy_find_action:
      yy_act = yy_accept[yy_current_state];
      if (yy_act == 0)
      { /* have to back up */
        yy_cp = (yy_last_accepting_cpos);
        yy_current_state = (yy_last_accepting_state);
        yy_act = yy_accept[yy_current_state];
      }

      YY_DO_BEFORE_ACTION;

      if (yy_act != YY_END_OF_BUFFER && yy_rule_can_match_eol[yy_act])
      {
        int yyl;
        for (yyl = 0; yyl < yyleng; ++yyl)
          if (yytext[yyl] == '\n')

            yylineno++;
        ;
      }

    do_action: /* This label is used only to access EOF actions. */

      switch (yy_act)
      {         /* beginning of action switch */
        case 0: /* must back up */
          /* undo the effects of YY_DO_BEFORE_ACTION */
          *yy_cp = (yy_hold_char);
          yy_cp = (yy_last_accepting_cpos);
          yy_current_state = (yy_last_accepting_state);
          goto yy_find_action;

        case 1:
          YY_RULE_SETUP
          {
            doxygen_comment();
          }
          YY_BREAK
        case 2:
          YY_RULE_SETUP
          {
            doxygen_comment();
          }
          YY_BREAK
        case 3:
          YY_RULE_SETUP
          {
            skip_comment();
          }
          YY_BREAK
        case 4:
          YY_RULE_SETUP
          {
            skip_ahead_until("@end");
          }
          YY_BREAK
        case 5:
          YY_RULE_SETUP
          {
            doxygen_cpp_comment();
          }
          YY_BREAK
        case 6:
          YY_RULE_SETUP
          {
            doxygen_cpp_comment();
          }
          YY_BREAK
        case 7:
          YY_RULE_SETUP
          {
            doxygen_group_start();
          }
          YY_BREAK
        case 8:
          YY_RULE_SETUP
          {
            doxygen_group_end();
          }
          YY_BREAK
        case 9:
          YY_RULE_SETUP
          {
            vtk_comment();
          }
          YY_BREAK
        case 10:
          YY_RULE_SETUP
          {
            vtk_name_comment();
          }
          YY_BREAK
        case 11:
          YY_RULE_SETUP
          {
            vtk_section_comment();
          }
          YY_BREAK
        case 12:
          YY_RULE_SETUP
          {
            cpp_comment_line();
          }
          YY_BREAK
        case 13:
          /* rule 13 can match eol */
          YY_RULE_SETUP
          {
            blank_line();
          }
          YY_BREAK
        case 14:
          YY_RULE_SETUP
          /* eat trailing C++ comments */
          YY_BREAK
        case 15:
          /* rule 15 can match eol */
          YY_RULE_SETUP
          {
            skip_trailing_comment(yytext, yyleng);
            preprocessor_directive(yytext, yyleng);
          }
          YY_BREAK
        case 16:
          /* rule 16 can match eol */
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (STRING_LITERAL);
          }
          YY_BREAK
        case 17:
          /* rule 17 can match eol */
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (CHAR_LITERAL);
          }
          YY_BREAK
        case 18:
          YY_RULE_SETUP
          {
            yylval.str = raw_string(yytext);
            return (STRING_LITERAL);
          }
          YY_BREAK
        case 19:
          YY_RULE_SETUP
          return (AUTO);
          YY_BREAK
        case 20:
          YY_RULE_SETUP
          return (DOUBLE);
          YY_BREAK
        case 21:
          YY_RULE_SETUP
          return (FLOAT);
          YY_BREAK
        case 22:
          YY_RULE_SETUP
          return (SHORT);
          YY_BREAK
        case 23:
          YY_RULE_SETUP
          return (LONG);
          YY_BREAK
        case 24:
          YY_RULE_SETUP
          return (CHAR);
          YY_BREAK
        case 25:
          YY_RULE_SETUP
          return (INT);
          YY_BREAK
        case 26:
          YY_RULE_SETUP
          return (UNSIGNED);
          YY_BREAK
        case 27:
          YY_RULE_SETUP
          return (SIGNED);
          YY_BREAK
        case 28:
          YY_RULE_SETUP
          return (VOID);
          YY_BREAK
        case 29:
          YY_RULE_SETUP
          return (BOOL);
          YY_BREAK
        case 30:
          YY_RULE_SETUP
          return (CHAR16_T);
          YY_BREAK
        case 31:
          YY_RULE_SETUP
          return (CHAR32_T);
          YY_BREAK
        case 32:
          YY_RULE_SETUP
          return (WCHAR_T);
          YY_BREAK
        case 33:
          /* rule 33 can match eol */
          *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
          YY_LINENO_REWIND_TO(yy_cp - 1);
          (yy_c_buf_p) = yy_cp -= 1;
          YY_DO_BEFORE_ACTION; /* set up yytext again */
          YY_RULE_SETUP
          {
            yylval.str = (yytext[3] == ':' ? "std::size_t" : "size_t");
            return (SIZE_T);
          }
          YY_BREAK
        case 34:
          /* rule 34 can match eol */
          *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
          YY_LINENO_REWIND_TO(yy_cp - 1);
          (yy_c_buf_p) = yy_cp -= 1;
          YY_DO_BEFORE_ACTION; /* set up yytext again */
          YY_RULE_SETUP
          {
            yylval.str = (yytext[3] == ':' ? "std::ssize_t" : "ssize_t");
            return (SSIZE_T);
          }
          YY_BREAK
        case 35:
          /* rule 35 can match eol */
          *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
          YY_LINENO_REWIND_TO(yy_cp - 1);
          (yy_c_buf_p) = yy_cp -= 1;
          YY_DO_BEFORE_ACTION; /* set up yytext again */
          YY_RULE_SETUP
          {
            yylval.str = (yytext[3] == ':' ? "std::nullptr_t" : "nullptr_t");
            return (NULLPTR_T);
          }
          YY_BREAK
        case 36:
          YY_RULE_SETUP
          /* ignore the Q_OBJECT macro from Qt */
          YY_BREAK
        case 37:
          /* rule 37 can match eol */
          *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
          YY_LINENO_REWIND_TO(yy_cp - 1);
          (yy_c_buf_p) = yy_cp -= 1;
          YY_DO_BEFORE_ACTION; /* set up yytext again */
          YY_RULE_SETUP
          return (PUBLIC);
          YY_BREAK
        case 38:
          /* rule 38 can match eol */
          *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
          YY_LINENO_REWIND_TO(yy_cp - 1);
          (yy_c_buf_p) = yy_cp -= 1;
          YY_DO_BEFORE_ACTION; /* set up yytext again */
          YY_RULE_SETUP
          return (PRIVATE);
          YY_BREAK
        case 39:
          /* rule 39 can match eol */
          *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
          YY_LINENO_REWIND_TO(yy_cp - 1);
          (yy_c_buf_p) = yy_cp -= 1;
          YY_DO_BEFORE_ACTION; /* set up yytext again */
          YY_RULE_SETUP
          return (PROTECTED);
          YY_BREAK
        case 40:
          /* rule 40 can match eol */
          *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
          YY_LINENO_REWIND_TO(yy_cp - 1);
          (yy_c_buf_p) = yy_cp -= 1;
          YY_DO_BEFORE_ACTION; /* set up yytext again */
          YY_RULE_SETUP
          return (PROTECTED);
          YY_BREAK
        case 41:
          YY_RULE_SETUP
          return (CLASS);
          YY_BREAK
        case 42:
          YY_RULE_SETUP
          return (STRUCT);
          YY_BREAK
        case 43:
          YY_RULE_SETUP
          return (PUBLIC);
          YY_BREAK
        case 44:
          YY_RULE_SETUP
          return (PRIVATE);
          YY_BREAK
        case 45:
          YY_RULE_SETUP
          return (PROTECTED);
          YY_BREAK
        case 46:
          YY_RULE_SETUP
          return (ENUM);
          YY_BREAK
        case 47:
          YY_RULE_SETUP
          return (UNION);
          YY_BREAK
        case 48:
          YY_RULE_SETUP
          return (VIRTUAL);
          YY_BREAK
        case 49:
          YY_RULE_SETUP
          return (CONST);
          YY_BREAK
        case 50:
          YY_RULE_SETUP
          return (VOLATILE);
          YY_BREAK
        case 51:
          YY_RULE_SETUP
          return (MUTABLE);
          YY_BREAK
        case 52:
          YY_RULE_SETUP
          return (OPERATOR);
          YY_BREAK
        case 53:
          YY_RULE_SETUP
          return (FRIEND);
          YY_BREAK
        case 54:
          YY_RULE_SETUP
          return (INLINE);
          YY_BREAK
        case 55:
          YY_RULE_SETUP
          return (CONSTEXPR);
          YY_BREAK
        case 56:
          YY_RULE_SETUP
          return (STATIC);
          YY_BREAK
        case 57:
          YY_RULE_SETUP
          return (THREAD_LOCAL);
          YY_BREAK
        case 58:
          YY_RULE_SETUP
          return (EXTERN);
          YY_BREAK
        case 59:
          YY_RULE_SETUP
          return (TEMPLATE);
          YY_BREAK
        case 60:
          YY_RULE_SETUP
          return (TYPENAME);
          YY_BREAK
        case 61:
          YY_RULE_SETUP
          return (TYPEDEF);
          YY_BREAK
        case 62:
          YY_RULE_SETUP
          return (NAMESPACE);
          YY_BREAK
        case 63:
          YY_RULE_SETUP
          return (USING);
          YY_BREAK
        case 64:
          YY_RULE_SETUP
          return (NEW);
          YY_BREAK
        case 65:
          YY_RULE_SETUP
          return (DELETE);
          YY_BREAK
        case 66:
          YY_RULE_SETUP
          return (EXPLICIT);
          YY_BREAK
        case 67:
          YY_RULE_SETUP
          return (THROW);
          YY_BREAK
        case 68:
          YY_RULE_SETUP
          return (TRY);
          YY_BREAK
        case 69:
          YY_RULE_SETUP
          return (CATCH);
          YY_BREAK
        case 70:
          YY_RULE_SETUP
          return (NOEXCEPT);
          YY_BREAK
        case 71:
          YY_RULE_SETUP
          return (DECLTYPE);
          YY_BREAK
        case 72:
          YY_RULE_SETUP
          return (DEFAULT);
          YY_BREAK
        case 73:
          YY_RULE_SETUP
          return (STATIC_CAST);
          YY_BREAK
        case 74:
          YY_RULE_SETUP
          return (DYNAMIC_CAST);
          YY_BREAK
        case 75:
          YY_RULE_SETUP
          return (CONST_CAST);
          YY_BREAK
        case 76:
          YY_RULE_SETUP
          return (REINTERPRET_CAST);
          YY_BREAK
        case 77:
          YY_RULE_SETUP
          /* irrelevant to wrappers */
          YY_BREAK
        case 78:
          YY_RULE_SETUP
          return (OP_LOGIC_AND);
          YY_BREAK
        case 79:
          YY_RULE_SETUP
          return (OP_AND_EQ);
          YY_BREAK
        case 80:
          YY_RULE_SETUP
          return (OP_LOGIC_OR);
          YY_BREAK
        case 81:
          YY_RULE_SETUP
          return (OP_OR_EQ);
          YY_BREAK
        case 82:
          YY_RULE_SETUP
          return ('!');
          YY_BREAK
        case 83:
          YY_RULE_SETUP
          return (OP_LOGIC_NEQ);
          YY_BREAK
        case 84:
          YY_RULE_SETUP
          return ('^');
          YY_BREAK
        case 85:
          YY_RULE_SETUP
          return (OP_XOR_EQ);
          YY_BREAK
        case 86:
          YY_RULE_SETUP
          return ('&');
          YY_BREAK
        case 87:
          YY_RULE_SETUP
          return ('|');
          YY_BREAK
        case 88:
          YY_RULE_SETUP
          return ('~');
          YY_BREAK
        case 89:
          /* rule 89 can match eol */
          YY_RULE_SETUP
          {
            size_t i = 1;
            size_t j;
            while (yytext[i] == ' ' || yytext[i] == '\t' || yytext[i] == '\r' || yytext[i] == '\n')
            {
              i++;
            }
            j = i;
            while (yytext[j] != '&')
            {
              j++;
            }
            yylval.str = vtkstrndup(&yytext[i], j - i);
            return (LA);
          }
          YY_BREAK
        case 90:
          /* rule 90 can match eol */
          YY_RULE_SETUP
          {
            size_t i = 1;
            size_t j;
            while (yytext[i] == ' ' || yytext[i] == '\t' || yytext[i] == '\r' || yytext[i] == '\n')
            {
              i++;
            }
            j = i;
            while (yytext[j] != '*')
            {
              j++;
            }
            yylval.str = vtkstrndup(&yytext[i], j - i);
            return (LP);
          }
          YY_BREAK
        case 91:
          /* rule 91 can match eol */
          YY_RULE_SETUP
          {
            yylval.str = "";
            return (LP);
          }
          YY_BREAK
        case 92:
          /* rule 92 can match eol */
          YY_RULE_SETUP
          {
            yylval.str = "";
            return (LP);
          }
          YY_BREAK
        case 93:
          /* rule 93 can match eol */
          YY_RULE_SETUP
          {
            yylval.str = "";
            return (LP);
          }
          YY_BREAK
        case 94:
          YY_RULE_SETUP
          return ('*');
          YY_BREAK
        case 95:
          YY_RULE_SETUP
          /* misc unused win32 macros */
          YY_BREAK
        case 96:
          /* rule 96 can match eol */
          *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
          YY_LINENO_REWIND_TO(yy_cp - 1);
          (yy_c_buf_p) = yy_cp -= 1;
          YY_DO_BEFORE_ACTION; /* set up yytext again */
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (OSTREAM);
          }
          YY_BREAK
        case 97:
          /* rule 97 can match eol */
          *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
          YY_LINENO_REWIND_TO(yy_cp - 1);
          (yy_c_buf_p) = yy_cp -= 1;
          YY_DO_BEFORE_ACTION; /* set up yytext again */
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (ISTREAM);
          }
          YY_BREAK
        case 98:
          /* rule 98 can match eol */
          *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
          YY_LINENO_REWIND_TO(yy_cp - 1);
          (yy_c_buf_p) = yy_cp -= 1;
          YY_DO_BEFORE_ACTION; /* set up yytext again */
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (StdString);
          }
          YY_BREAK
        case 99:
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (StdString);
          }
          YY_BREAK
        case 100:
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (QT_ID);
          }
          YY_BREAK
        case 101:
          YY_RULE_SETUP
          skip_macro_arguments(); /* C++11 */
          YY_BREAK
        case 102:
          YY_RULE_SETUP
          skip_macro_arguments(); /* C++11 */
          YY_BREAK
        case 103:
          YY_RULE_SETUP
          skip_macro_arguments(); /* C11 */
          YY_BREAK
        case 104:
          YY_RULE_SETUP
          skip_macro_arguments(); /* C11 */
          YY_BREAK
        case 105:
          YY_RULE_SETUP
          return (THREAD_LOCAL); /* C11 */
          YY_BREAK
        case 106:
          YY_RULE_SETUP
          /* C11 */
          YY_BREAK
        case 107:
          YY_RULE_SETUP
          /* C11 */
          YY_BREAK
        case 108:
          YY_RULE_SETUP
          skip_macro_arguments(); /* C99 */
          YY_BREAK
        case 109:
          YY_RULE_SETUP
          skip_macro_arguments(); /* MSVC */
          YY_BREAK
        case 110:
          YY_RULE_SETUP
          skip_macro_arguments(); /* gcc attributes */
          YY_BREAK
        case 111:
          YY_RULE_SETUP
          skip_macro_arguments(); /* Windows linkage */
          YY_BREAK
        case 112:
          YY_RULE_SETUP
          /* Windows */
          YY_BREAK
        case 113:
          YY_RULE_SETUP
          /* gcc/clang/other extension */
          YY_BREAK
        case 114:
          YY_RULE_SETUP
          /* MSVC extension */
          YY_BREAK
        case 115:
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (NULLPTR);
          }
          YY_BREAK
        case 116:
          YY_RULE_SETUP
          {
            const char* name = vtkstrndup(yytext, yyleng);
            MacroInfo* macro = vtkParsePreprocess_GetMacro(preprocessor, name);
            int expanded = 0;
            if (macro)
            {
              char* args = NULL;
              const char* emacro = NULL;

              if (macro->IsFunction)
              {
                args = get_macro_arguments();
                if (args)
                {
                  emacro = vtkParsePreprocess_ExpandMacro(preprocessor, macro, args);
                  if (!emacro)
                  {
                    print_preprocessor_error(VTK_PARSE_MACRO_NUMARGS, NULL, 0);
                    exit(1);
                  }
                  free(args);
                }
              }
              else if (macro->Definition && macro->Definition[0])
              {
                /* first see if macro evaluates to a constant value */
                preproc_int_t val;
                int is_unsigned;
                int r;
                macro->IsExcluded = 1;
                r = vtkParsePreprocess_EvaluateExpression(
                  preprocessor, macro->Definition, &val, &is_unsigned);
                macro->IsExcluded = 0;
                /* if it isn't a constant expression, then expand it */
                if (r >= VTK_PARSE_MACRO_UNDEFINED)
                {
                  emacro = vtkParsePreprocess_ExpandMacro(preprocessor, macro, NULL);
                  if (!emacro)
                  {
                    print_preprocessor_error(r, NULL, 0);
                    exit(1);
                  }
                }
              }
              else
              {
                /* macros with no definition expand to nothing */
                expanded = 1;
              }
              if (emacro)
              {
                /* invoke the parser on any expanded macros */
                push_macro(macro);
                push_buffer();
                yy_switch_to_buffer(yy_scan_string(emacro));
                vtkParsePreprocess_FreeMacroExpansion(preprocessor, macro, emacro);
                expanded = 1;
              }
            }
            if (!expanded)
            {
              /* if no macro expansion occurred, return the ID */
              yylval.str = name;
              if (yyleng > 3 && name[0] == 'v' && name[1] == 't' && name[2] == 'k')
              {
                return (VTK_ID);
              }
              else if (name[0] == 'Q')
              {
                return (QT_ID);
              }
              else
              {
                return (ID);
              }
            }
          }
          YY_BREAK
        case 117:
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (FLOAT_LITERAL);
          }
          YY_BREAK
        case 118:
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (FLOAT_LITERAL);
          }
          YY_BREAK
        case 119:
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (FLOAT_LITERAL);
          }
          YY_BREAK
        case 120:
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (FLOAT_LITERAL);
          }
          YY_BREAK
        case 121:
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (HEX_LITERAL);
          }
          YY_BREAK
        case 122:
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (BIN_LITERAL);
          }
          YY_BREAK
        case 123:
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (OCT_LITERAL);
          }
          YY_BREAK
        case 124:
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (INT_LITERAL);
          }
          YY_BREAK
        case 125:
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (ZERO);
          }
          YY_BREAK
        case 126:
          /* rule 126 can match eol */
          YY_RULE_SETUP
          /* escaped newlines */
          YY_BREAK
        case 127:
          YY_RULE_SETUP
          /* whitespace */
          YY_BREAK
        case 128:
          /* rule 128 can match eol */
          YY_RULE_SETUP
          /* whitespace */
          YY_BREAK
        case 129:
          /* rule 129 can match eol */
          YY_RULE_SETUP
          return (BEGIN_ATTRIB);
          YY_BREAK
        case 130:
          YY_RULE_SETUP
          return ('{');
          YY_BREAK
        case 131:
          YY_RULE_SETUP
          return ('}');
          YY_BREAK
        case 132:
          YY_RULE_SETUP
          return ('[');
          YY_BREAK
        case 133:
          YY_RULE_SETUP
          return (']');
          YY_BREAK
        case 134:
          YY_RULE_SETUP
          return ('#');
          YY_BREAK
        case 135:
          *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
          (yy_c_buf_p) = yy_cp = yy_bp + 1;
          YY_DO_BEFORE_ACTION; /* set up yytext again */
          YY_RULE_SETUP
          return (OP_RSHIFT_A);
          YY_BREAK
        case 136:
          YY_RULE_SETUP
          return (OP_LSHIFT_EQ);
          YY_BREAK
        case 137:
          YY_RULE_SETUP
          return (OP_RSHIFT_EQ);
          YY_BREAK
        case 138:
          YY_RULE_SETUP
          return (OP_LSHIFT);
          YY_BREAK
        case 139:
          YY_RULE_SETUP
          return (OP_DOT_POINTER);
          YY_BREAK
        case 140:
          YY_RULE_SETUP
          return (OP_ARROW_POINTER);
          YY_BREAK
        case 141:
          YY_RULE_SETUP
          return (OP_ARROW);
          YY_BREAK
        case 142:
          YY_RULE_SETUP
          return (OP_INCR);
          YY_BREAK
        case 143:
          YY_RULE_SETUP
          return (OP_DECR);
          YY_BREAK
        case 144:
          YY_RULE_SETUP
          return (OP_PLUS_EQ);
          YY_BREAK
        case 145:
          YY_RULE_SETUP
          return (OP_MINUS_EQ);
          YY_BREAK
        case 146:
          YY_RULE_SETUP
          return (OP_TIMES_EQ);
          YY_BREAK
        case 147:
          YY_RULE_SETUP
          return (OP_DIVIDE_EQ);
          YY_BREAK
        case 148:
          YY_RULE_SETUP
          return (OP_REMAINDER_EQ);
          YY_BREAK
        case 149:
          YY_RULE_SETUP
          return (OP_AND_EQ);
          YY_BREAK
        case 150:
          YY_RULE_SETUP
          return (OP_OR_EQ);
          YY_BREAK
        case 151:
          YY_RULE_SETUP
          return (OP_XOR_EQ);
          YY_BREAK
        case 152:
          YY_RULE_SETUP
          return (OP_LOGIC_AND);
          YY_BREAK
        case 153:
          YY_RULE_SETUP
          return (OP_LOGIC_OR);
          YY_BREAK
        case 154:
          YY_RULE_SETUP
          return (OP_LOGIC_EQ);
          YY_BREAK
        case 155:
          YY_RULE_SETUP
          return (OP_LOGIC_NEQ);
          YY_BREAK
        case 156:
          YY_RULE_SETUP
          return (OP_LOGIC_LEQ);
          YY_BREAK
        case 157:
          YY_RULE_SETUP
          return (OP_LOGIC_GEQ);
          YY_BREAK
        case 158:
          YY_RULE_SETUP
          return (ELLIPSIS);
          YY_BREAK
        case 159:
          YY_RULE_SETUP
          return (DOUBLE_COLON);
          YY_BREAK
        case 160:
          YY_RULE_SETUP
          return ('[');
          YY_BREAK
        case 161:
          YY_RULE_SETUP
          return (']');
          YY_BREAK
        case 162:
          YY_RULE_SETUP
          return (yytext[0]);
          YY_BREAK
        case YY_STATE_EOF(INITIAL):
        {
          if (!pop_buffer())
          {
            yyterminate();
          }
        }
          YY_BREAK
        case 163:
          YY_RULE_SETUP
          {
            return (OTHER);
          }
          YY_BREAK
        case 164:
          YY_RULE_SETUP
          YY_FATAL_ERROR("flex scanner jammed");
          YY_BREAK

        case YY_END_OF_BUFFER:
        {
          /* Amount of text matched not including the EOB char. */
          int yy_amount_of_matched_text = (int)(yy_cp - (yytext_ptr)) - 1;

          /* Undo the effects of YY_DO_BEFORE_ACTION. */
          *yy_cp = (yy_hold_char);
          YY_RESTORE_YY_MORE_OFFSET

          if (YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW)
          {
            /* We're scanning a new file or input source.  It's
             * possible that this happened because the user
             * just pointed yyin at a new source and called
             * yylex().  If so, then we have to assure
             * consistency between YY_CURRENT_BUFFER and our
             * globals.  Here is the right place to do so, because
             * this is the first action (other than possibly a
             * back-up) that will match for the new input source.
             */
            (yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
            YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
            YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
          }

          /* Note that here we test for yy_c_buf_p "<=" to the position
           * of the first EOB in the buffer, since yy_c_buf_p will
           * already have been incremented past the NUL character
           * (since all states make transitions on EOB to the
           * end-of-buffer state).  Contrast this with the test
           * in input().
           */
          if ((yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)])
          { /* This was really a NUL. */
            yy_state_type yy_next_state;

            (yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;

            yy_current_state = yy_get_previous_state();

            /* Okay, we're now positioned to make the NUL
             * transition.  We couldn't have
             * yy_get_previous_state() go ahead and do it
             * for us because it doesn't know how to deal
             * with the possibility of jamming (and we don't
             * want to build jamming into it because then it
             * will run more slowly).
             */

            yy_next_state = yy_try_NUL_trans(yy_current_state);

            yy_bp = (yytext_ptr) + YY_MORE_ADJ;

            if (yy_next_state)
            {
              /* Consume the NUL. */
              yy_cp = ++(yy_c_buf_p);
              yy_current_state = yy_next_state;
              goto yy_match;
            }

            else
            {
              yy_cp = (yy_c_buf_p);
              goto yy_find_action;
            }
          }

          else
            switch (yy_get_next_buffer())
            {
              case EOB_ACT_END_OF_FILE:
              {
                (yy_did_buffer_switch_on_eof) = 0;

                if (yywrap())
                {
                  /* Note: because we've taken care in
                   * yy_get_next_buffer() to have set up
                   * yytext, we can now set up
                   * yy_c_buf_p so that if some total
                   * hoser (like flex itself) wants to
                   * call the scanner after we return the
                   * YY_NULL, it'll still work - another
                   * YY_NULL will get returned.
                   */
                  (yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;

                  yy_act = YY_STATE_EOF(YY_START);
                  goto do_action;
                }

                else
                {
                  if (!(yy_did_buffer_switch_on_eof))
                    YY_NEW_FILE;
                }
                break;
              }

              case EOB_ACT_CONTINUE_SCAN:
                (yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;

                yy_current_state = yy_get_previous_state();

                yy_cp = (yy_c_buf_p);
                yy_bp = (yytext_ptr) + YY_MORE_ADJ;
                goto yy_match;

              case EOB_ACT_LAST_MATCH:
                (yy_c_buf_p) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];

                yy_current_state = yy_get_previous_state();

                yy_cp = (yy_c_buf_p);
                yy_bp = (yytext_ptr) + YY_MORE_ADJ;
                goto yy_find_action;
            }
          break;
        }

        default:
          YY_FATAL_ERROR("fatal flex scanner internal error--no action found");
      } /* end of action switch */
    }   /* end of scanning one token */
  }     /* end of user's declarations */
} /* end of yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *  EOB_ACT_LAST_MATCH -
 *  EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *  EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer(void)
{
  char* dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
  char* source = (yytext_ptr);
  int number_to_move, i;
  int ret_val;

  if ((yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1])
    YY_FATAL_ERROR("fatal flex scanner internal error--end of buffer missed");

  if (YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0)
  { /* Don't try to fill the buffer, so this is an EOF. */
    if ((yy_c_buf_p) - (yytext_ptr)-YY_MORE_ADJ == 1)
    {
      /* We matched a single character, the EOB, so
       * treat this as a final EOF.
       */
      return EOB_ACT_END_OF_FILE;
    }

    else
    {
      /* We matched some text prior to the EOB, first
       * process it.
       */
      return EOB_ACT_LAST_MATCH;
    }
  }

  /* Try to read more data. */

  /* First move last chars to start of buffer. */
  number_to_move = (int)((yy_c_buf_p) - (yytext_ptr)-1);

  for (i = 0; i < number_to_move; ++i)
    *(dest++) = *(source++);

  if (YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING)
    /* don't do the read, it's not guaranteed to return an EOF,
     * just force an EOF
     */
    YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;

  else
  {
    int num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

    while (num_to_read <= 0)
    { /* Not enough room in the buffer - grow it. */

      /* just a shorter name for the current buffer */
      YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;

      int yy_c_buf_p_offset = (int)((yy_c_buf_p)-b->yy_ch_buf);

      if (b->yy_is_our_buffer)
      {
        int new_size = b->yy_buf_size * 2;

        if (new_size <= 0)
          b->yy_buf_size += b->yy_buf_size / 8;
        else
          b->yy_buf_size *= 2;

        b->yy_ch_buf = (char*)
          /* Include room in for 2 EOB chars. */
          yyrealloc((void*)b->yy_ch_buf, (yy_size_t)(b->yy_buf_size + 2));
      }
      else
        /* Can't grow it, we don't own it. */
        b->yy_ch_buf = NULL;

      if (!b->yy_ch_buf)
        YY_FATAL_ERROR("fatal error - scanner input buffer overflow");

      (yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];

      num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
    }

    if (num_to_read > YY_READ_BUF_SIZE)
      num_to_read = YY_READ_BUF_SIZE;

    /* Read in more data. */
    YY_INPUT((&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]), (yy_n_chars), num_to_read);

    YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
  }

  if ((yy_n_chars) == 0)
  {
    if (number_to_move == YY_MORE_ADJ)
    {
      ret_val = EOB_ACT_END_OF_FILE;
      yyrestart(yyin);
    }

    else
    {
      ret_val = EOB_ACT_LAST_MATCH;
      YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_EOF_PENDING;
    }
  }

  else
    ret_val = EOB_ACT_CONTINUE_SCAN;

  if (((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size)
  {
    /* Extend the array by 50%, plus the number we really need. */
    int new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
    YY_CURRENT_BUFFER_LVALUE->yy_ch_buf =
      (char*)yyrealloc((void*)YY_CURRENT_BUFFER_LVALUE->yy_ch_buf, (yy_size_t)new_size);
    if (!YY_CURRENT_BUFFER_LVALUE->yy_ch_buf)
      YY_FATAL_ERROR("out of dynamic memory in yy_get_next_buffer()");
    /* "- 2" to take care of EOB's */
    YY_CURRENT_BUFFER_LVALUE->yy_buf_size = (int)(new_size - 2);
  }

  (yy_n_chars) += number_to_move;
  YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
  YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;

  (yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

  return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was reached */

static yy_state_type yy_get_previous_state(void)
{
  yy_state_type yy_current_state;
  char* yy_cp;

  yy_current_state = (yy_start);
  yy_current_state += YY_AT_BOL();

  for (yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp)
  {
    YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
    if (yy_accept[yy_current_state])
    {
      (yy_last_accepting_state) = yy_current_state;
      (yy_last_accepting_cpos) = yy_cp;
    }
    while (yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state)
    {
      yy_current_state = (int)yy_def[yy_current_state];
      if (yy_current_state >= 963)
        yy_c = yy_meta[yy_c];
    }
    yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
  }

  return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *  next_state = yy_try_NUL_trans( current_state );
 */
static yy_state_type yy_try_NUL_trans(yy_state_type yy_current_state)
{
  int yy_is_jam;
  char* yy_cp = (yy_c_buf_p);

  YY_CHAR yy_c = 1;
  if (yy_accept[yy_current_state])
  {
    (yy_last_accepting_state) = yy_current_state;
    (yy_last_accepting_cpos) = yy_cp;
  }
  while (yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state)
  {
    yy_current_state = (int)yy_def[yy_current_state];
    if (yy_current_state >= 963)
      yy_c = yy_meta[yy_c];
  }
  yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
  yy_is_jam = (yy_current_state == 962);

  return yy_is_jam ? 0 : yy_current_state;
}

#ifndef YY_NO_UNPUT

static void yyunput(int c, char* yy_bp)
{
  char* yy_cp;

  yy_cp = (yy_c_buf_p);

  /* undo effects of setting up yytext */
  *yy_cp = (yy_hold_char);

  if (yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2)
  { /* need to shift things up to make room */
    /* +2 for EOB chars. */
    int number_to_move = (yy_n_chars) + 2;
    char* dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
    char* source = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];

    while (source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf)
      *--dest = *--source;

    yy_cp += (int)(dest - source);
    yy_bp += (int)(dest - source);
    YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) =
      (int)YY_CURRENT_BUFFER_LVALUE->yy_buf_size;

    if (yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2)
      YY_FATAL_ERROR("flex scanner push-back overflow");
  }

  *--yy_cp = (char)c;

  if (c == '\n')
  {
    --yylineno;
  }

  (yytext_ptr) = yy_bp;
  (yy_hold_char) = *yy_cp;
  (yy_c_buf_p) = yy_cp;
}

#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
static int yyinput(void)
#else
static int input(void)
#endif

{
  int c;

  *(yy_c_buf_p) = (yy_hold_char);

  if (*(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR)
  {
    /* yy_c_buf_p now points to the character we want to return.
     * If this occurs *before* the EOB characters, then it's a
     * valid NUL; if not, then we've hit the end of the buffer.
     */
    if ((yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)])
      /* This was really a NUL. */
      *(yy_c_buf_p) = '\0';

    else
    { /* need more input */
      int offset = (int)((yy_c_buf_p) - (yytext_ptr));
      ++(yy_c_buf_p);

      switch (yy_get_next_buffer())
      {
        case EOB_ACT_LAST_MATCH:
          /* This happens because yy_g_n_b()
           * sees that we've accumulated a
           * token and flags that we need to
           * try matching the token before
           * proceeding.  But for input(),
           * there's no matching to consider.
           * So convert the EOB_ACT_LAST_MATCH
           * to EOB_ACT_END_OF_FILE.
           */

          /* Reset buffer status. */
          yyrestart(yyin);

          /*FALLTHROUGH*/

        case EOB_ACT_END_OF_FILE:
        {
          if (yywrap())
            return 0;

          if (!(yy_did_buffer_switch_on_eof))
            YY_NEW_FILE;
#ifdef __cplusplus
          return yyinput();
#else
          return input();
#endif
        }

        case EOB_ACT_CONTINUE_SCAN:
          (yy_c_buf_p) = (yytext_ptr) + offset;
          break;
      }
    }
  }

  c = *(unsigned char*)(yy_c_buf_p); /* cast for 8-bit char's */
  *(yy_c_buf_p) = '\0';              /* preserve yytext */
  (yy_hold_char) = *++(yy_c_buf_p);

  YY_CURRENT_BUFFER_LVALUE->yy_at_bol = (c == '\n');
  if (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)

    yylineno++;
  ;

  return c;
}
#endif /* ifndef YY_NO_INPUT */

/** Immediately switch to a different input stream.
 * @param input_file A readable stream.
 *
 * @note This function does not reset the start condition to @c INITIAL .
 */
void yyrestart(FILE* input_file)
{

  if (!YY_CURRENT_BUFFER)
  {
    yyensure_buffer_stack();
    YY_CURRENT_BUFFER_LVALUE = yy_create_buffer(yyin, YY_BUF_SIZE);
  }

  yy_init_buffer(YY_CURRENT_BUFFER, input_file);
  yy_load_buffer_state();
}

/** Switch to a different input buffer.
 * @param new_buffer The new input buffer.
 *
 */
void yy_switch_to_buffer(YY_BUFFER_STATE new_buffer)
{

  /* TODO. We should be able to replace this entire function body
   * with
   *    yypop_buffer_state();
   *    yypush_buffer_state(new_buffer);
   */
  yyensure_buffer_stack();
  if (YY_CURRENT_BUFFER == new_buffer)
    return;

  if (YY_CURRENT_BUFFER)
  {
    /* Flush out information for old buffer. */
    *(yy_c_buf_p) = (yy_hold_char);
    YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
    YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
  }

  YY_CURRENT_BUFFER_LVALUE = new_buffer;
  yy_load_buffer_state();

  /* We don't actually know whether we did this switch during
   * EOF (yywrap()) processing, but the only time this flag
   * is looked at is after yywrap() is called, so it's safe
   * to go ahead and always set it.
   */
  (yy_did_buffer_switch_on_eof) = 1;
}

static void yy_load_buffer_state(void)
{
  (yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
  (yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
  yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
  (yy_hold_char) = *(yy_c_buf_p);
}

/** Allocate and initialize an input buffer state.
 * @param file A readable stream.
 * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
 *
 * @return the allocated buffer state.
 */
YY_BUFFER_STATE yy_create_buffer(FILE* file, int size)
{
  YY_BUFFER_STATE b;

  b = (YY_BUFFER_STATE)yyalloc(sizeof(struct yy_buffer_state));
  if (!b)
    YY_FATAL_ERROR("out of dynamic memory in yy_create_buffer()");

  b->yy_buf_size = size;

  /* yy_ch_buf has to be 2 characters longer than the size given because
   * we need to put in 2 end-of-buffer characters.
   */
  b->yy_ch_buf = (char*)yyalloc((yy_size_t)(b->yy_buf_size + 2));
  if (!b->yy_ch_buf)
    YY_FATAL_ERROR("out of dynamic memory in yy_create_buffer()");

  b->yy_is_our_buffer = 1;

  yy_init_buffer(b, file);

  return b;
}

/** Destroy the buffer.
 * @param b a buffer created with yy_create_buffer()
 *
 */
void yy_delete_buffer(YY_BUFFER_STATE b)
{

  if (!b)
    return;

  if (b == YY_CURRENT_BUFFER) /* Not sure if we should pop here. */
    YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE)0;

  if (b->yy_is_our_buffer)
    yyfree((void*)b->yy_ch_buf);

  yyfree((void*)b);
}

/* Initializes or reinitializes a buffer.
 * This function is sometimes called more than once on the same buffer,
 * such as during a yyrestart() or at EOF.
 */
static void yy_init_buffer(YY_BUFFER_STATE b, FILE* file)

{
  int oerrno = errno;

  yy_flush_buffer(b);

  b->yy_input_file = file;
  b->yy_fill_buffer = 1;

  /* If b is the current buffer, then yy_init_buffer was _probably_
   * called from yyrestart() or through yy_get_next_buffer.
   * In that case, we don't want to reset the lineno or column.
   */
  if (b != YY_CURRENT_BUFFER)
  {
    b->yy_bs_lineno = 1;
    b->yy_bs_column = 0;
  }

  b->yy_is_interactive = file ? (isatty(fileno(file)) > 0) : 0;

  errno = oerrno;
}

/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
 * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
 *
 */
void yy_flush_buffer(YY_BUFFER_STATE b)
{
  if (!b)
    return;

  b->yy_n_chars = 0;

  /* We always need two end-of-buffer characters.  The first causes
   * a transition to the end-of-buffer state.  The second causes
   * a jam in that state.
   */
  b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
  b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;

  b->yy_buf_pos = &b->yy_ch_buf[0];

  b->yy_at_bol = 1;
  b->yy_buffer_status = YY_BUFFER_NEW;

  if (b == YY_CURRENT_BUFFER)
    yy_load_buffer_state();
}

/** Pushes the new state onto the stack. The new state becomes
 *  the current state. This function will allocate the stack
 *  if necessary.
 *  @param new_buffer The new state.
 *
 */
void yypush_buffer_state(YY_BUFFER_STATE new_buffer)
{
  if (new_buffer == NULL)
    return;

  yyensure_buffer_stack();

  /* This block is copied from yy_switch_to_buffer. */
  if (YY_CURRENT_BUFFER)
  {
    /* Flush out information for old buffer. */
    *(yy_c_buf_p) = (yy_hold_char);
    YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
    YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
  }

  /* Only push if top exists. Otherwise, replace top. */
  if (YY_CURRENT_BUFFER)
    (yy_buffer_stack_top)++;
  YY_CURRENT_BUFFER_LVALUE = new_buffer;

  /* copied from yy_switch_to_buffer. */
  yy_load_buffer_state();
  (yy_did_buffer_switch_on_eof) = 1;
}

/** Removes and deletes the top of the stack, if present.
 *  The next element becomes the new top.
 *
 */
void yypop_buffer_state(void)
{
  if (!YY_CURRENT_BUFFER)
    return;

  yy_delete_buffer(YY_CURRENT_BUFFER);
  YY_CURRENT_BUFFER_LVALUE = NULL;
  if ((yy_buffer_stack_top) > 0)
    --(yy_buffer_stack_top);

  if (YY_CURRENT_BUFFER)
  {
    yy_load_buffer_state();
    (yy_did_buffer_switch_on_eof) = 1;
  }
}

/* Allocates the stack if it does not exist.
 *  Guarantees space for at least one push.
 */
static void yyensure_buffer_stack(void)
{
  yy_size_t num_to_alloc;

  if (!(yy_buffer_stack))
  {

    /* First allocation is just for 2 elements, since we don't know if this
     * scanner will even need a stack. We use 2 instead of 1 to avoid an
     * immediate realloc on the next call.
     */
    num_to_alloc = 1; /* After all that talk, this was set to 1 anyways... */
    (yy_buffer_stack) =
      (struct yy_buffer_state**)yyalloc(num_to_alloc * sizeof(struct yy_buffer_state*));
    if (!(yy_buffer_stack))
      YY_FATAL_ERROR("out of dynamic memory in yyensure_buffer_stack()");

    memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));

    (yy_buffer_stack_max) = num_to_alloc;
    (yy_buffer_stack_top) = 0;
    return;
  }

  if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1)
  {

    /* Increase the buffer to prepare for a possible push. */
    yy_size_t grow_size = 8 /* arbitrary grow size */;

    num_to_alloc = (yy_buffer_stack_max) + grow_size;
    (yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc(
      (yy_buffer_stack), num_to_alloc * sizeof(struct yy_buffer_state*));
    if (!(yy_buffer_stack))
      YY_FATAL_ERROR("out of dynamic memory in yyensure_buffer_stack()");

    /* zero only the new slots.*/
    memset(
      (yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
    (yy_buffer_stack_max) = num_to_alloc;
  }
}

/** Setup the input buffer state to scan directly from a user-specified character buffer.
 * @param base the character buffer
 * @param size the size in bytes of the character buffer
 *
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE yy_scan_buffer(char* base, yy_size_t size)
{
  YY_BUFFER_STATE b;

  if (size < 2 || base[size - 2] != YY_END_OF_BUFFER_CHAR ||
    base[size - 1] != YY_END_OF_BUFFER_CHAR)
    /* They forgot to leave room for the EOB's. */
    return NULL;

  b = (YY_BUFFER_STATE)yyalloc(sizeof(struct yy_buffer_state));
  if (!b)
    YY_FATAL_ERROR("out of dynamic memory in yy_scan_buffer()");

  b->yy_buf_size = (int)(size - 2); /* "- 2" to take care of EOB's */
  b->yy_buf_pos = b->yy_ch_buf = base;
  b->yy_is_our_buffer = 0;
  b->yy_input_file = NULL;
  b->yy_n_chars = b->yy_buf_size;
  b->yy_is_interactive = 0;
  b->yy_at_bol = 1;
  b->yy_fill_buffer = 0;
  b->yy_buffer_status = YY_BUFFER_NEW;

  yy_switch_to_buffer(b);

  return b;
}

/** Setup the input buffer state to scan a string. The next call to yylex() will
 * scan from a @e copy of @a str.
 * @param yystr a NUL-terminated string to scan
 *
 * @return the newly allocated buffer state object.
 * @note If you want to scan bytes that may contain NUL values, then use
 *       yy_scan_bytes() instead.
 */
YY_BUFFER_STATE yy_scan_string(const char* yystr)
{

  return yy_scan_bytes(yystr, (int)strlen(yystr));
}

/** Setup the input buffer state to scan the given bytes. The next call to yylex() will
 * scan from a @e copy of @a bytes.
 * @param yybytes the byte buffer to scan
 * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
 *
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE yy_scan_bytes(const char* yybytes, int _yybytes_len)
{
  YY_BUFFER_STATE b;
  char* buf;
  yy_size_t n;
  int i;

  /* Get memory for full buffer, including space for trailing EOB's. */
  n = (yy_size_t)(_yybytes_len + 2);
  buf = (char*)yyalloc(n);
  if (!buf)
    YY_FATAL_ERROR("out of dynamic memory in yy_scan_bytes()");

  for (i = 0; i < _yybytes_len; ++i)
    buf[i] = yybytes[i];

  buf[_yybytes_len] = buf[_yybytes_len + 1] = YY_END_OF_BUFFER_CHAR;

  b = yy_scan_buffer(buf, n);
  if (!b)
    YY_FATAL_ERROR("bad buffer in yy_scan_bytes()");

  /* It's okay to grow etc. this buffer, and we should throw it
   * away when we're done.
   */
  b->yy_is_our_buffer = 1;

  return b;
}

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

static void yynoreturn yy_fatal_error(const char* msg)
{
  fprintf(stderr, "%s\n", msg);
  exit(YY_EXIT_FAILURE);
}

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n)                                                                                  \
  do                                                                                               \
  {                                                                                                \
    /* Undo effects of setting up yytext. */                                                       \
    int yyless_macro_arg = (n);                                                                    \
    YY_LESS_LINENO(yyless_macro_arg);                                                              \
    yytext[yyleng] = (yy_hold_char);                                                               \
    (yy_c_buf_p) = yytext + yyless_macro_arg;                                                      \
    (yy_hold_char) = *(yy_c_buf_p);                                                                \
    *(yy_c_buf_p) = '\0';                                                                          \
    yyleng = yyless_macro_arg;                                                                     \
  } while (0)

/* Accessor  methods (get/set functions) to struct members. */

/** Get the current line number.
 *
 */
int yyget_lineno(void)
{

  return yylineno;
}

/** Get the input stream.
 *
 */
FILE* yyget_in(void)
{
  return yyin;
}

/** Get the output stream.
 *
 */
FILE* yyget_out(void)
{
  return yyout;
}

/** Get the length of the current token.
 *
 */
int yyget_leng(void)
{
  return yyleng;
}

/** Get the current token.
 *
 */

char* yyget_text(void)
{
  return yytext;
}

/** Set the current line number.
 * @param _line_number line number
 *
 */
void yyset_lineno(int _line_number)
{

  yylineno = _line_number;
}

/** Set the input stream. This does not discard the current
 * input buffer.
 * @param _in_str A readable stream.
 *
 * @see yy_switch_to_buffer
 */
void yyset_in(FILE* _in_str)
{
  yyin = _in_str;
}

void yyset_out(FILE* _out_str)
{
  yyout = _out_str;
}

int yyget_debug(void)
{
  return yy_flex_debug;
}

void yyset_debug(int _bdebug)
{
  yy_flex_debug = _bdebug;
}

static int yy_init_globals(void)
{
  /* Initialization is the same as for the non-reentrant scanner.
   * This function is called from yylex_destroy(), so don't allocate here.
   */

  /* We do not touch yylineno unless the option is enabled. */
  yylineno = 1;

  (yy_buffer_stack) = NULL;
  (yy_buffer_stack_top) = 0;
  (yy_buffer_stack_max) = 0;
  (yy_c_buf_p) = NULL;
  (yy_init) = 0;
  (yy_start) = 0;

/* Defined in main.c */
#ifdef YY_STDINIT
  yyin = stdin;
  yyout = stdout;
#else
  yyin = NULL;
  yyout = NULL;
#endif

  /* For future reference: Set errno on error, since we are called by
   * yylex_init()
   */
  return 0;
}

/* yylex_destroy is for both reentrant and non-reentrant scanners. */
int yylex_destroy(void)
{

  /* Pop the buffer stack, destroying each element. */
  while (YY_CURRENT_BUFFER)
  {
    yy_delete_buffer(YY_CURRENT_BUFFER);
    YY_CURRENT_BUFFER_LVALUE = NULL;
    yypop_buffer_state();
  }

  /* Destroy the stack itself. */
  yyfree((yy_buffer_stack));
  (yy_buffer_stack) = NULL;

  /* Reset the globals. This is important in a non-reentrant scanner so the next time
   * yylex() is called, initialization will occur. */
  yy_init_globals();

  return 0;
}

/*
 * Internal utility routines.
 */

#ifndef yytext_ptr
static void yy_flex_strncpy(char* s1, const char* s2, int n)
{

  int i;
  for (i = 0; i < n; ++i)
    s1[i] = s2[i];
}
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen(const char* s)
{
  int n;
  for (n = 0; s[n]; ++n)
    ;

  return n;
}
#endif

void* yyalloc(yy_size_t size)
{
  return malloc(size);
}

void* yyrealloc(void* ptr, yy_size_t size)
{

  /* The cast to (char *) in the following accommodates both
   * implementations that use char* generic pointers, and those
   * that use void* generic pointers.  It works with the latter
   * because both ANSI C and C++ allow castless assignment from
   * any pointer type to void*, and deal with argument conversions
   * as though doing an assignment.
   */
  return realloc(ptr, size);
}

void yyfree(void* ptr)
{
  free((char*)ptr); /* see yyrealloc() for (char *) cast */
}

#define YYTABLES_NAME "yytables"

/*
 * Return a parenthetical macro arg list as a new string.
 */
char* get_macro_arguments()
{
  char* cp = NULL;
  size_t i = 0;
  int depth;
  int ws = 0;
  int sl = 0;
  int c1 = input();

  if (c1 == '\0')
  {
    if (pop_buffer() == 0)
    {
      return NULL;
    }
  }

  while (c1 == ' ' || c1 == '\t' || c1 == '\r' || c1 == '\n')
  {
    c1 = input();
  }

  cp = (char*)malloc(4);

  if (c1 != '(')
  {
    unput(c1);
    free(cp);
    return NULL;
  }

  cp[i++] = '(';
  depth = 1;
  c1 = input();

  for (;;)
  {
    ws = 0;
    sl = 0;
    /* skip all whitespace */
    while (c1 == ' ' || c1 == '\t' || c1 == '\r' || c1 == '\n')
    {
      ws = 1;
      c1 = input();
    }
    if (c1 == '/')
    {
      c1 = input();
      if (c1 == '*')
      {
        /* skip a C style comment */
        ws = 1;
        if (skip_comment() == 0)
        {
          return NULL;
        }
        c1 = input();
      }
      else if (c1 == '/')
      {
        /* skip a C++ style comment */
        ws = 1;
        do
        {
          c1 = input();
        } while (c1 != '\n' && c1 != '\0');
        if (c1 == '\0')
        {
          return NULL;
        }
        c1 = input();
      }
      else
      {
        sl = 1;
      }
    }
    if (ws)
    {
      /* add a single space to replace any whitespace */
      cp[i++] = ' ';
      if (i >= 4 && (i & (i - 1)) == 0)
      {
        char* oldcp = cp;
        cp = (char*)realloc(cp, 2 * i);
        if (!cp)
        {
          free(oldcp);
          return NULL;
        }
      }
    }
    if (sl)
    {
      /* add a single space to replace any whitespace */
      cp[i++] = '/';
      if (i >= 4 && (i & (i - 1)) == 0)
      {
        char* oldcp = cp;
        cp = (char*)realloc(cp, 2 * i);
        if (!cp)
        {
          free(oldcp);
          return NULL;
        }
      }
    }
    if (c1 == '\"' || c1 == '\'')
    {
      int c2 = c1;
      int escaped = 2;
      int firstloop = 1;
      do
      {
        if (escaped)
        {
          --escaped;
        }
        if (!firstloop)
        {
          c1 = input();
        }
        firstloop = 0;
        if (c1 == '\0')
        {
          break;
        }
        if (escaped == 0 && c1 == '\\')
        {
          escaped = 2;
        }
        cp[i++] = (char)c1;
        if (i >= 4 && (i & (i - 1)) == 0)
        {
          char* oldcp = cp;
          cp = (char*)realloc(cp, 2 * i);
          if (!cp)
          {
            free(oldcp);
            return NULL;
          }
        }
      } while (c1 != c2 || escaped);
    }
    else if (c1 != '\0')
    {
      cp[i++] = (char)c1;
      if (i >= 4 && (i & (i - 1)) == 0)
      {
        char* oldcp = cp;
        cp = (char*)realloc(cp, 2 * i);
        if (!cp)
        {
          free(oldcp);
          return NULL;
        }
      }
      cp[i] = '\0';
      if (c1 == '(')
      {
        depth++;
      }
      if (c1 == ')')
      {
        if (--depth == 0)
        {
          break;
        }
      }
    }
    else
    {
      return NULL;
    }
    c1 = input();
  }

  return cp;
}

void skip_macro_arguments()
{
  char* p = get_macro_arguments();
  free(p);
}

/*
 * Skip a C-style comment, return 0 if unterminated.
 */
int skip_comment()
{
  int savelineno = yylineno;
  int c1 = 0, c2 = input();
  for (;;)
  {
    if (c2 == 0 || c2 == EOF)
    {
      yylineno = savelineno;
      print_preprocessor_error(VTK_PARSE_SYNTAX_ERROR, "Cannot find end of comment.", 27);
      exit(1);
    }
    if (c1 == '*' && c2 == '/')
      break;
    c1 = c2;
    c2 = input();
  }
  return 1;
}

/*
 * If token contains a comment, make sure whole comment is skipped.
 */
int skip_trailing_comment(const char* text, size_t l)
{
  const char* cp = text;
  const char* ep = text + l;
  int incomment = 0;

  while (cp < ep)
  {
    while (cp < ep && *cp != '/' && *cp != '\"')
    {
      cp++;
    }
    if (cp >= ep)
    {
      break;
    }
    else if (cp[0] == '/' && cp[1] == '*')
    {
      incomment = 1;
      cp += 2;
      while (cp < ep && *cp != '*')
      {
        cp++;
      }
      if (cp[0] == '*' && cp[1] == '/')
      {
        incomment = 0;
        cp += 2;
      }
      else
      {
        cp++;
      }
    }
    else if (cp[0] == '\"')
    {
      cp++;
      while (cp < ep)
      {
        while (cp < ep && *cp != '\\' && *cp != '\"')
        {
          cp++;
        }
        if (cp >= ep)
        {
          break;
        }
        else if (*cp == '\"')
        {
          cp++;
          break;
        }
        else /* if (*cp == '\\') */
        {
          cp += 2;
        }
      }
    }
    else
    {
      cp++;
    }
  }

  if (incomment)
  {
    return skip_comment();
  }

  return 1;
}

/*
 * Skip ahead until the next preprocessor directive.
 * This will eat the '#' that starts the directive.
 * Return 0 if none found.
 */
int skip_to_next_directive()
{
  /* state == 0 at the start of a line */
  int state = 0;
  int c;

  c = input();

  while (c != 0 && c != EOF)
  {
    /* whitespace */
    if (c == ' ' || c == '\t')
    {
      c = input();
    }
    /* newline renews the start-of-line state */
    else if (c == '\n')
    {
      state = 0;
      c = input();
    }
    /* skip comments */
    else if (c == '/')
    {
      state = 1;
      if ((c = input()) == '*')
      {
        if (skip_comment() == 0)
        {
          return 0;
        }
        c = input();
      }
    }
    /* skip escaped characters */
    else if (c == '\\')
    {
      state = 1;
      if ((c = input()) == '\r')
      {
        if ((c = input()) == '\n')
        {
          c = input();
        }
      }
      else if (c != 0 && c != EOF)
      {
        c = input();
      }
    }
    /* any other chars except '#' at start of line */
    else if (c != '#' || state != 0)
    {
      state = 1;
      c = input();
    }
    else
    {
      break;
    }
  }

  return c;
}

/*
 * Skip to the next #else or #elif or #endif
 */
int skip_conditional_block()
{
  static char* linebuf = NULL;
  static size_t linemaxlen = 80;
  size_t i;
  int c;
  int result;

  if (linebuf == 0)
  {
    linebuf = (char*)malloc(linemaxlen);
  }

  for (;;)
  {
    if (skip_to_next_directive() == 0)
    {
      return 0;
    }
    c = input();
    while (c == ' ' || c == '\t')
    {
      c = input();
    }
    if (c == 0 || c == EOF)
    {
      return 0;
    }

    /* eat the whole line */
    i = 0;
    linebuf[i++] = '#';
    while (c != 0 && c != EOF && c != '\n')
    {
      if (i >= linemaxlen - 5)
      {
        char* oldlinebuf = linebuf;
        linemaxlen += i + 5;
        linebuf = (char*)realloc(linebuf, linemaxlen);
        if (!linebuf)
        {
          free(oldlinebuf);
          return 0;
        }
      }
      linebuf[i++] = c;
      /* be sure to skip escaped newlines */
      if (c == '\\')
      {
        c = input();
        linebuf[i++] = c;
        if (c == '\r')
        {
          c = input();
          linebuf[i++] = c;
        }
      }
      c = input();
    }
    linebuf[i++] = c;

    result = vtkParsePreprocess_HandleDirective(preprocessor, linebuf);
    if (result != VTK_PARSE_SKIP && result != VTK_PARSE_OK)
    {
      print_preprocessor_error(result, linebuf, i);
    }
    else if (result != VTK_PARSE_SKIP)
    {
      break;
    }
  }

  return 1;
}

/*
 * Skip ahead until one of the strings is found,
 * then skip to the end of the line.
 */
int skip_ahead_multi(const char* strings[])
{
  char textbuf[SKIP_MATCH_MAXLEN + 1];
  int c = 0;
  size_t i;

  for (i = 0; i < (SKIP_MATCH_MAXLEN + 1); i++)
  {
    textbuf[i] = '\0';
  }

  for (;;)
  {
    for (i = 0; i < SKIP_MATCH_MAXLEN; i++)
    {
      textbuf[i] = textbuf[i + 1];
    }

    c = input();
    if (c == 0 || c == EOF)
    {
      print_preprocessor_error(VTK_PARSE_SYNTAX_ERROR, NULL, 0);
      return 0;
    }

    textbuf[SKIP_MATCH_MAXLEN - 1] = c;

    for (i = 0; strings[i]; i++)
    {
      if (strcmp(&textbuf[SKIP_MATCH_MAXLEN - strlen(strings[i])], strings[i]) == 0)
      {
        break;
      }
    }
    if (strings[i])
    {
      break;
    }
  }

  while (c != 0 && c != EOF && c != '\n')
  {
    c = input();
  }

  return 1;
}

/*
 * Skip ahead until the string is found.
 */
int skip_ahead_until(const char* text)
{
  const char* strings[2];
  strings[0] = text;
  strings[1] = NULL;

  return skip_ahead_multi(strings);
}

/*
 * Called for doxygen C-style comments
 */
void doxygen_comment()
{
  char linetext[256];
  int savelineno = yylineno;
  int asterisk, isfirstline = 1;
  int type = DoxygenComment;
  int l = 0, i = 0, base = yyleng;
  int c1 = 0, c2 = input();
  for (l = 0; l < yyleng; l++)
  {
    linetext[l] = yytext[l];
  }
  if (l > 0 && yytext[l - 1] == '<')
  {
    type = TrailingComment;
  }
  for (;;)
  {
    if (c2 == 0 || c2 == EOF)
    {
      yylineno = savelineno;
      print_preprocessor_error(VTK_PARSE_SYNTAX_ERROR, "Cannot find end of comment.", 27);
      exit(1);
    }
    if (l < 256)
    {
      linetext[l++] = (char)c2;
    }
    if (c2 == '\n' || (c1 == '*' && c2 == '/'))
    {
      if (l >= 2 && linetext[l - 2] == '*' && linetext[l - 1] == '/')
      {
        l -= 2;
      }
      while (l > 0 &&
        (linetext[l - 1] == '\n' || linetext[l - 1] == '\r' || linetext[l - 1] == '\t' ||
          linetext[l - 1] == ' '))
      {
        l--;
      }
      if (!isfirstline)
      {
        /* reduce the base indentation if chars occur before base */
        asterisk = 0;
        for (i = yyleng - 3; i < base && i < l; i++)
        {
          if (linetext[i] == '*' && asterisk == 0)
          {
            asterisk = 1;
          }
          else if (linetext[i] != ' ')
          {
            break;
          }
        }
        if (i > yyleng - 3 && i < l && linetext[i] != ' ' && linetext[i - 1] == ' ')
        {
          i--;
        }
        base = i;
      }
      if (l > base)
      {
        i = base;
        l -= base;
        addCommentLine(&linetext[i], l, type);
      }
      else if (c1 != '*' || c2 != '/')
      {
        addCommentLine("", 0, type);
      }
      if (isfirstline)
      {
        isfirstline = 0;
        base = 256;
      }
      l = 0;
      if (c1 == '*' && c2 == '/')
      {
        break;
      }
    }
    c1 = c2;
    c2 = input();
  }
}

/*
 * Called for //! and /// doxygen comments (handles just one line)
 */
void doxygen_cpp_comment()
{
  int type = DoxygenComment;
  int pos = 2;
  while (yytext[pos - 2] != '/' || yytext[pos - 1] != '/')
    pos++;
  while (pos < yyleng && yytext[pos - 1] == '/' && yytext[pos] == '/')
    pos++;
  if (pos < yyleng && yytext[pos] == '!')
    pos++;
  if (pos < yyleng && yytext[pos] == '<')
  {
    pos++;
    type = TrailingComment;
  }
  addCommentLine(&yytext[pos], yyleng - pos, type);
}

/*
 * Called for ///@{
 */
void doxygen_group_start()
{
  /* Set the "ingroup" marker */
  setCommentMemberGroup(1);
}

/*
 * Called for ///@}
 */
void doxygen_group_end()
{
  /* Clear the "ingroup" marker */
  setCommentMemberGroup(0);
}

/*
 * Called for // Description:
 */
void vtk_comment()
{
  setCommentState(NormalComment);
}

/*
 * Called for // .NAME
 */
void vtk_name_comment()
{
  int pos = 1;
  while (yytext[pos - 1] != 'M' || yytext[pos] != 'E')
  {
    pos++;
  }
  pos++;
  setCommentState(NameComment);
  addCommentLine(&yytext[pos], yyleng - pos, NormalComment);
}

/*
 * Called for // .SECTION
 */
void vtk_section_comment()
{
  int pos = 1;
  while (yytext[pos - 1] != 'O' || yytext[pos] != 'N')
  {
    pos++;
  }
  pos++;
  if (pos < yyleng && yytext[pos] == ' ')
  {
    pos++;
  }

  if (yyleng - pos >= 11 && strncmp(&yytext[pos], "Description", 11) == 0)
  {
    setCommentState(DescriptionComment);
  }
  else if (yyleng - pos >= 8 &&
    (strncmp(&yytext[pos], "See Also", 8) == 0 || strncmp(&yytext[pos], "see also", 8) == 0))
  {
    setCommentState(SeeAlsoComment);
  }
  else if (yyleng - pos >= 7 && strncmp(&yytext[pos], "Caveats", 7) == 0)
  {
    setCommentState(CaveatsComment);
  }
  else
  {
    cpp_comment_line();
  }
}

/*
 * Called for each line that has a C++ comment but no code, unless the
 * comment is recognized as beginning a VTK or doxygen comment.
 */
void cpp_comment_line()
{
  int pos = 2;
  while (yytext[pos - 2] != '/' || yytext[pos - 1] != '/')
    pos++;
  addCommentLine(&yytext[pos], yyleng - pos, NormalComment);
}

/*
 * Called whenever a blank line is encountered.
 */
void blank_line()
{
  commentBreak();
}

/*
 * Convert a raw string into a non-raw string.
 */
const char* raw_string(const char* begin)
{
  int savelineno = yylineno;
  char* textbuf;
  int c = 0;
  const char* delim;
  const char* cp = begin;
  char* dp;
  char* result;
  size_t i, j, n;
  size_t m = 1024;

  result = (char*)malloc(m);
  dp = result;

  while (*cp != '\"')
  {
    *dp++ = *cp++;
  }
  --dp;
  *dp++ = *cp++;

  delim = cp;

  for (n = 0;; n++)
  {
    if (delim[n] == '(')
    {
      break;
    }
  }

  textbuf = (char*)malloc(n + 1);

  for (i = 0; i < n + 1; i++)
  {
    c = input();
    textbuf[i] = c;
  }

  while (c != EOF)
  {
    if (textbuf[0] == ')' && (n == 0 || strncmp(&textbuf[1], delim, n) == 0))
    {
      break;
    }

    j = dp - result;
    if (j > m - 8)
    {
      m += 1024;
      result = (char*)realloc(result, m);
      if (!result)
      {
        print_preprocessor_error(VTK_PARSE_OUT_OF_MEMORY, NULL, 0);
        exit(1);
      }
      dp = result + j;
    }

    if ((*textbuf >= ' ' && *textbuf <= '~') || (*textbuf & 0x80) != 0)
    {
      *dp++ = *textbuf;
    }
    else
      switch (*textbuf)
      {
        case '\a':
          *dp++ = '\\';
          *dp++ = 'a';
          break;
        case '\b':
          *dp++ = '\\';
          *dp++ = 'b';
          break;
        case '\f':
          *dp++ = '\\';
          *dp++ = 'f';
          break;
        case '\n':
          *dp++ = '\\';
          *dp++ = 'n';
          break;
        case '\r':
          *dp++ = '\\';
          *dp++ = 'r';
          break;
        case '\t':
          *dp++ = '\\';
          *dp++ = 't';
          break;
        case '\v':
          *dp++ = '\\';
          *dp++ = 'v';
          break;
        case '\\':
          *dp++ = '\\';
          *dp++ = '\\';
          break;
        case '\'':
          *dp++ = '\\';
          *dp++ = '\'';
          break;
        case '\"':
          *dp++ = '\\';
          *dp++ = '\"';
          break;
        default:
          sprintf(dp, "\\%3.3o", *textbuf);
          dp += 4;
          break;
      }

    for (i = 0; i < n; i++)
    {
      textbuf[i] = textbuf[i + 1];
    }

    c = input();
    textbuf[n] = c;
  }

  if (c == EOF || '\"' != input())
  {
    yylineno = savelineno;
    print_preprocessor_error(VTK_PARSE_SYNTAX_ERROR, "Unterminated raw string.", 24);
    exit(1);
  }

  *dp++ = '\"';

  c = input();
  if (c == '_')
  {
    do
    {
      *dp++ = c;
      c = input();
    } while (vtkParse_CharType(c, CPRE_XID));
  }
  unput(c);

  *dp = '\0';
  cp = vtkstrdup(result);
  free(result);
  free(textbuf);

  return cp;
}

/*
 * buffer stack, used for macro expansion and include files
 */
static size_t buffer_stack_size = 0;
static YY_BUFFER_STATE* buffer_stack = NULL;

/*
 * push the current buffer onto the buffer stack.
 */
void push_buffer()
{
  size_t n = buffer_stack_size;
  if (buffer_stack == NULL)
  {
    buffer_stack = (YY_BUFFER_STATE*)malloc(4 * sizeof(YY_BUFFER_STATE));
  }
  /* grow the stack whenever size reaches a power of two */
  else if (n >= 4 && (n & (n - 1)) == 0)
  {
    buffer_stack = (YY_BUFFER_STATE*)realloc(buffer_stack, 2 * n * sizeof(YY_BUFFER_STATE));
    if (!buffer_stack)
    {
      print_preprocessor_error(VTK_PARSE_OUT_OF_MEMORY, NULL, 0);
      exit(1);
    }
  }
  buffer_stack[buffer_stack_size++] = YY_CURRENT_BUFFER;
}

/*
 * pop the buffer stack and restore the previous buffer
 */
int pop_buffer()
{
  if (in_macro())
  {
    pop_macro();
  }
  else
  {
    pop_include();
  }
  if (buffer_stack_size == 0)
  {
    return 0;
  }
  yy_delete_buffer(YY_CURRENT_BUFFER);
  yy_switch_to_buffer(buffer_stack[--buffer_stack_size]);
  return 1;
}

/*
 * include stack, to tell what include is being evaluated
 */
static size_t include_stack_size = 0;
static FileInfo** include_stack = NULL;
static int* lineno_stack = NULL;

/*
 * push the current include onto the include stack.
 */
void push_include(const char* filename)
{
  FileInfo* file_info = NULL;
  int same_file = 0;
  size_t n = include_stack_size;

  if (include_stack == NULL)
  {
    include_stack = (FileInfo**)malloc(4 * sizeof(FileInfo*));
    lineno_stack = (int*)malloc(4 * sizeof(int));
  }

  /* grow the stack whenever size reaches a power of two */
  else if (n >= 4 && (n & (n - 1)) == 0)
  {
    include_stack = (FileInfo**)realloc(include_stack, 2 * n * sizeof(FileInfo*));
    if (!include_stack)
    {
      print_preprocessor_error(VTK_PARSE_OUT_OF_MEMORY, NULL, 0);
      exit(1);
    }
    lineno_stack = (int*)realloc(lineno_stack, 2 * n * sizeof(int));
    if (!lineno_stack)
    {
      print_preprocessor_error(VTK_PARSE_OUT_OF_MEMORY, NULL, 0);
      exit(1);
    }
  }

  lineno_stack[include_stack_size] = yyget_lineno();
  yyset_lineno(0);
  include_stack[include_stack_size++] = data;

  /* if the file is including itself */
  if (filename == data->FileName ||
    (filename != 0 && data->FileName != 0 && strcmp(filename, data->FileName) == 0))
  {
    same_file = 1;
  }

  /* make a new fileinfo, but only if we are in the base namespace
   * and only if the only items added so far are constants */
  if (!same_file && currentNamespace == data->Contents &&
    data->Contents->NumberOfItems == data->Contents->NumberOfConstants)
  {
    file_info = (FileInfo*)malloc(sizeof(FileInfo));
    vtkParse_InitFile(file_info);
    file_info->FileName = vtkstrdup(filename);
    file_info->Contents = (NamespaceInfo*)malloc(sizeof(NamespaceInfo));
    vtkParse_InitNamespace(file_info->Contents);
    vtkParse_AddIncludeToFile(data, file_info);
    file_info->Strings = data->Strings;
    data = file_info;
    currentNamespace = file_info->Contents;
  }
}

/*
 * pop the include stack
 */
void pop_include()
{
  if (include_stack_size > 0)
  {
    --include_stack_size;
    fclose(yyin);
    yyset_lineno(lineno_stack[include_stack_size]);
    if (data != include_stack[include_stack_size])
    {
      data = include_stack[include_stack_size];
      currentNamespace = data->Contents;
    }
  }
}

/*
 * macro stack, to tell what macro is being evaluated
 */
static size_t macro_stack_size = 0;
static MacroInfo** macro_stack = NULL;

/*
 * push the current macro onto the macro stack.
 */
void push_macro(MacroInfo* macro)
{
  size_t n = macro_stack_size;
  if (macro_stack == NULL)
  {
    macro_stack = (MacroInfo**)malloc(4 * sizeof(MacroInfo*));
  }
  /* grow the stack whenever size reaches a power of two */
  else if (n >= 4 && (n & (n - 1)) == 0)
  {
    macro_stack = (MacroInfo**)realloc(macro_stack, 2 * n * sizeof(MacroInfo*));
    if (!macro_stack)
    {
      print_preprocessor_error(VTK_PARSE_OUT_OF_MEMORY, NULL, 0);
      exit(1);
    }
  }
  macro_stack[macro_stack_size++] = macro;
  if (macro)
  {
    macro->IsExcluded = 1;
    if (macro_stack_size == 1)
    {
      macroName = macro->Name;
      macroUsed = 0;
      macroEnded = 0;
    }
  }
}

/*
 * pop the macro stack
 */
void pop_macro()
{
  MacroInfo* macro;

  if (macro_stack_size > 0)
  {
    macro = macro_stack[--macro_stack_size];
    if (macro)
    {
      macro->IsExcluded = 0;
    }
  }
  macroEnded = 1;
}

/*
 * are we currently processing a macro?
 */
int in_macro()
{
  return (macro_stack_size > 0);
}

/*
 * print a preprocessor error code with filename and line number.
 */
void print_preprocessor_error(int result, const char* cp, size_t n)
{
  const char* text = "";

  switch (result)
  {
    case VTK_PARSE_OK:
    case VTK_PARSE_SKIP:
      return;
    case VTK_PARSE_PREPROC_DOUBLE:
      text = "double in preprocessor conditional";
      break;
    case VTK_PARSE_PREPROC_FLOAT:
      text = "float in preprocessor conditional";
      break;
    case VTK_PARSE_PREPROC_STRING:
      text = "string in preprocessor conditional";
      break;
    case VTK_PARSE_MACRO_UNDEFINED:
      text = "undefined macro";
      break;
    case VTK_PARSE_MACRO_REDEFINED:
      text = "redefined macro";
      break;
    case VTK_PARSE_FILE_NOT_FOUND:
      text = "file not found";
      break;
    case VTK_PARSE_FILE_OPEN_ERROR:
      text = "can\'t open file";
      break;
    case VTK_PARSE_FILE_READ_ERROR:
      text = "input/output error";
      break;
    case VTK_PARSE_MACRO_NUMARGS:
      text = "wrong number of macro args";
      break;
    case VTK_PARSE_SYNTAX_ERROR:
      text = "syntax error";
      break;
    case VTK_PARSE_OUT_OF_MEMORY:
      text = "out of memory";
      break;
  }

  /* be silent about missing include files */
  if (result == VTK_PARSE_FILE_NOT_FOUND)
  {
    return;
  }

  print_parser_error(text, cp, n);
}

/*
 * print an error with filename and line number.
 */
void print_parser_error(const char* text, const char* cp, size_t n)
{
  size_t j = 0;
  const char* fn = "(none)";

  if (CommandName)
  {
    fprintf(yyout, "%s: ", CommandName);
  }

  if (data->FileName)
  {
    fn = data->FileName;
  }
  fprintf(yyout, "In %s:", fn);
  for (j = 0; j < include_stack_size; j++)
  {
    fprintf(yyout, "%i:\nIn %s:", lineno_stack[j], include_stack[j]->FileName);
  }
  fprintf(yyout, "%i:", yylineno);

  if (cp)
  {
    fprintf(yyout, " %s: %*.*s\n", text, (int)n, (int)n, cp);
  }
  else if (text)
  {
    fprintf(yyout, " %s.\n", text);
  }
  else
  {
    fprintf(yyout, "\n");
  }
}

/*
 * Execute a preprocessor directive.
 */
void preprocessor_directive(const char* text, size_t l)
{
  int result = 0;
  size_t n = 0;
  const char* cp = text;
  const char* ep = text + l;
  const char* directive = NULL;

  /* find the directive, store its length in "n" */
  while (*cp == ' ' || *cp == '\t')
  {
    cp++;
  }
  if (*cp == '#')
  {
    cp++;
  }
  while ((*cp == ' ' || *cp == '\t') && cp < ep)
  {
    cp++;
  }
  directive = cp;
  while (*cp >= 'a' && *cp <= 'z' && cp < ep)
  {
    cp++;
  }
  n = cp - directive;
  while ((*cp == ' ' || *cp == '\t') && cp < ep)
  {
    cp++;
  }

  if (n == 7 && strncmp(directive, "include", n) == 0)
  {
    /* include files */
    int already_loaded = 0;
    if (*cp == '<' || *cp == '\"')
    {
      /* if asked to recurse into header files */
      if (Recursive && ep - cp > 3)
      {
        const char* dp;
        dp = vtkParsePreprocess_FindIncludeFile(preprocessor, &cp[1],
          (*cp != '\"' ? VTK_PARSE_SYSTEM_INCLUDE : VTK_PARSE_SOURCE_INCLUDE), &already_loaded);
        if (dp)
        {
          yyin = vtkParse_FileOpen(dp, "r");
          if (yyin)
          {
            push_include(dp);
            push_buffer();
            yy_switch_to_buffer(yy_create_buffer(yyin, YY_BUF_SIZE));
            return;
          }
        }
      }
    }
  }

  /* let the preprocessor handle the directive */
  result = vtkParsePreprocess_HandleDirective(preprocessor, text);

  if (result == VTK_PARSE_SKIP)
  {
    skip_conditional_block();
  }
  else if (result != VTK_PARSE_OK)
  {
    print_preprocessor_error(result, text, l);
    if ((result & VTK_PARSE_FATAL_ERROR) != 0)
    {
      exit(1);
    }
  }
  else if (n == 6 && strncmp(directive, "define", n) == 0)
  {
    closeComment();
    if (ep - cp > 4 && strncmp(cp, "VTK", 3) == 0)
    {
      /* macros that start with "VTK" */
      MacroInfo* macro;

      macro = vtkParsePreprocess_GetMacro(preprocessor, cp);
      if (macro && macro->Definition && !macro->IsFunction)
      {
        /* if macro evaluates to a constant, add it as a constant */
        macro->IsExcluded = 1;
        if (guess_constant_type(macro->Definition) == 0)
        {
          result = VTK_PARSE_MACRO_UNDEFINED;
        }
        macro->IsExcluded = 0;
        if (result < VTK_PARSE_MACRO_UNDEFINED)
        {
          add_constant(vtkstrdup(macro->Name), vtkstrdup(macro->Definition), 0, 0, NULL, 1);
        }
      }
    }
  }
}
